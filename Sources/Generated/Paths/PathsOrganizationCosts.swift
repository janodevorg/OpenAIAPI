// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension Paths.Organization {
    public var costs: Costs {
        Costs(path: path + "/costs")
    }

    public struct Costs {
        /// Path: `/organization/costs`
        public let path: String

        /// Get costs details for the organization.
        public func get(parameters: GetParameters) -> Request<OpenAIAPI.UsageResponse> {
            Request(path: path, method: "GET", query: parameters.asQuery, id: "usage-costs")
        }

        public struct GetParameters {
            public var startTime: Int
            public var endTime: Int?
            public var bucketWidth: BucketWidth?
            public var projectIDs: [String]?
            public var groupBy: [GroupBy]?
            public var limit: Int?
            public var page: String?

            public enum BucketWidth: String, Codable, CaseIterable {
                case _1d = "1d"
            }

            public enum GroupBy: String, Codable, CaseIterable {
                case projectID = "project_id"
                case lineItem = "line_item"
            }

            public init(startTime: Int, endTime: Int? = nil, bucketWidth: BucketWidth? = nil, projectIDs: [String]? = nil, groupBy: [GroupBy]? = nil, limit: Int? = nil, page: String? = nil) {
                self.startTime = startTime
                self.endTime = endTime
                self.bucketWidth = bucketWidth
                self.projectIDs = projectIDs
                self.groupBy = groupBy
                self.limit = limit
                self.page = page
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(startTime, forKey: "start_time")
                encoder.encode(endTime, forKey: "end_time")
                encoder.encode(bucketWidth, forKey: "bucket_width")
                encoder.encode(projectIDs, forKey: "project_ids")
                encoder.encode(groupBy, forKey: "group_by")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(page, forKey: "page")
                return encoder.items
            }
        }
    }
}
