// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct CreateAssistantRequest: Codable {
    /// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.
    ///
    /// Example: "gpt-4o"
    public var model: Model
    /// The name of the assistant. The maximum length is 256 characters.
    public var name: String?
    /// The description of the assistant. The maximum length is 512 characters.
    public var description: String?
    /// The system instructions that the assistant uses. The maximum length is 256,000 characters.
    public var instructions: String?
    /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.
    public var tools: [Tool]?
    /// A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
    public var toolResources: ToolResources?
    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
    public var metadata: [String: AnyJSON]?
    /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
    public var temperature: Double?
    /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
    /// 
    /// We generally recommend altering this or temperature but not both.
    public var topP: Double?
    /// Specifies the format that the model must output. Compatible with [GPT-4o](/docs/models#gpt-4o), [GPT-4 Turbo](/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
    /// 
    /// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).
    /// 
    /// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
    /// 
    /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
    public var responseFormat: AssistantsAPIResponseFormatOption?

    /// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.
    ///
    /// Example: "gpt-4o"
    public struct Model: Codable {
        public var string: String?
        public var object: Object?

        public enum Object: String, Codable, CaseIterable {
            case gpt4o = "gpt-4o"
            case gpt4o20241120 = "gpt-4o-2024-11-20"
            case gpt4o20240806 = "gpt-4o-2024-08-06"
            case gpt4o20240513 = "gpt-4o-2024-05-13"
            case gpt4oMini = "gpt-4o-mini"
            case gpt4oMini20240718 = "gpt-4o-mini-2024-07-18"
            case gpt4Turbo = "gpt-4-turbo"
            case gpt4Turbo20240409 = "gpt-4-turbo-2024-04-09"
            case gpt40125Preview = "gpt-4-0125-preview"
            case gpt4TurboPreview = "gpt-4-turbo-preview"
            case gpt41106Preview = "gpt-4-1106-preview"
            case gpt4VisionPreview = "gpt-4-vision-preview"
            case gpt4 = "gpt-4"
            case gpt40314 = "gpt-4-0314"
            case gpt40613 = "gpt-4-0613"
            case gpt432k = "gpt-4-32k"
            case gpt432k0314 = "gpt-4-32k-0314"
            case gpt432k0613 = "gpt-4-32k-0613"
            case gpt35Turbo = "gpt-3.5-turbo"
            case gpt35Turbo16k = "gpt-3.5-turbo-16k"
            case gpt35Turbo0613 = "gpt-3.5-turbo-0613"
            case gpt35Turbo1106 = "gpt-3.5-turbo-1106"
            case gpt35Turbo0125 = "gpt-3.5-turbo-0125"
            case gpt35Turbo16k0613 = "gpt-3.5-turbo-16k-0613"
        }

        public init(string: String? = nil, object: Object? = nil) {
            self.string = string
            self.object = object
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.object = try? container.decode(Object.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = object { try container.encode(value) }
        }
    }

    public enum Tool: Codable {
        case assistantToolsCode(AssistantToolsCode)
        case assistantToolsFileSearch(AssistantToolsFileSearch)
        case assistantToolsFunction(AssistantToolsFunction)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(AssistantToolsCode.self) {
                self = .assistantToolsCode(value)
            } else if let value = try? container.decode(AssistantToolsFileSearch.self) {
                self = .assistantToolsFileSearch(value)
            } else if let value = try? container.decode(AssistantToolsFunction.self) {
                self = .assistantToolsFunction(value)
            } else {
                throw DecodingError.dataCorruptedError(
                    in: container,
                    debugDescription: "Data could not be decoded as any of the expected types (AssistantToolsCode, AssistantToolsFileSearch, AssistantToolsFunction)."
                )
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .assistantToolsCode(let value): try container.encode(value)
            case .assistantToolsFileSearch(let value): try container.encode(value)
            case .assistantToolsFunction(let value): try container.encode(value)
            }
        }
    }

    /// A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
    public struct ToolResources: Codable {
        public var codeInterpreter: CodeInterpreter?
        public var fileSearch: FileSearch?

        public struct CodeInterpreter: Codable {
            /// A list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.
            public var fileIDs: [String]?

            public init(fileIDs: [String]? = nil) {
                self.fileIDs = fileIDs
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.fileIDs = try values.decodeIfPresent([String].self, forKey: "file_ids")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(fileIDs, forKey: "file_ids")
            }
        }

        public enum FileSearch: Codable {
            case fileSearchWithIDs(FileSearchWithIDs)
            case fileSearchWithStores(FileSearchWithStores)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(FileSearchWithIDs.self) {
                    self = .fileSearchWithIDs(value)
                } else if let value = try? container.decode(FileSearchWithStores.self) {
                    self = .fileSearchWithStores(value)
                } else {
                    throw DecodingError.dataCorruptedError(
                        in: container,
                        debugDescription: "Data could not be decoded as any of the expected types (FileSearchWithIDs, FileSearchWithStores)."
                    )
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .fileSearchWithIDs(let value): try container.encode(value)
                case .fileSearchWithStores(let value): try container.encode(value)
                }
            }
        }

        public init(codeInterpreter: CodeInterpreter? = nil, fileSearch: FileSearch? = nil) {
            self.codeInterpreter = codeInterpreter
            self.fileSearch = fileSearch
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.codeInterpreter = try values.decodeIfPresent(CodeInterpreter.self, forKey: "code_interpreter")
            self.fileSearch = try values.decodeIfPresent(FileSearch.self, forKey: "file_search")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(codeInterpreter, forKey: "code_interpreter")
            try values.encodeIfPresent(fileSearch, forKey: "file_search")
        }
    }

    public init(model: Model, name: String? = nil, description: String? = nil, instructions: String? = nil, tools: [Tool]? = nil, toolResources: ToolResources? = nil, metadata: [String: AnyJSON]? = nil, temperature: Double? = nil, topP: Double? = nil, responseFormat: AssistantsAPIResponseFormatOption? = nil) {
        self.model = model
        self.name = name
        self.description = description
        self.instructions = instructions
        self.tools = tools
        self.toolResources = toolResources
        self.metadata = metadata
        self.temperature = temperature
        self.topP = topP
        self.responseFormat = responseFormat
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.model = try values.decode(Model.self, forKey: "model")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.instructions = try values.decodeIfPresent(String.self, forKey: "instructions")
        self.tools = try values.decodeIfPresent([Tool].self, forKey: "tools")
        self.toolResources = try values.decodeIfPresent(ToolResources.self, forKey: "tool_resources")
        self.metadata = try values.decodeIfPresent([String: AnyJSON].self, forKey: "metadata")
        self.temperature = try values.decodeIfPresent(Double.self, forKey: "temperature")
        self.topP = try values.decodeIfPresent(Double.self, forKey: "top_p")
        self.responseFormat = try values.decodeIfPresent(AssistantsAPIResponseFormatOption.self, forKey: "response_format")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(model, forKey: "model")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(instructions, forKey: "instructions")
        try values.encodeIfPresent(tools, forKey: "tools")
        try values.encodeIfPresent(toolResources, forKey: "tool_resources")
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encodeIfPresent(temperature, forKey: "temperature")
        try values.encodeIfPresent(topP, forKey: "top_p")
        try values.encodeIfPresent(responseFormat, forKey: "response_format")
    }
}
