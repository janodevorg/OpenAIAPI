// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Returned when an error occurs, which could be a client problem or a server 
/// problem. Most errors are recoverable and the session will stay open, we 
/// recommend to implementors to monitor and log error messages by default.
public struct RealtimeServerEventError: Codable {
    /// The unique ID of the server event.
    public var eventID: String
    /// The event type, must be `error`.
    public var type: `Type`
    /// Details of the error.
    public var error: Error

    /// The event type, must be `error`.
    public enum `Type`: String, Codable, CaseIterable {
        case error
    }

    /// Details of the error.
    public struct Error: Codable {
        /// The type of error (e.g., "invalid_request_error", "server_error").
        public var type: String
        /// Error code, if any.
        public var code: String?
        /// A human-readable error message.
        public var message: String
        /// Parameter related to the error, if any.
        public var param: String?
        /// The event_id of the client event that caused the error, if applicable.
        public var eventID: String?

        public init(type: String, code: String? = nil, message: String, param: String? = nil, eventID: String? = nil) {
            self.type = type
            self.code = code
            self.message = message
            self.param = param
            self.eventID = eventID
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.type = try values.decode(String.self, forKey: "type")
            self.code = try values.decodeIfPresent(String.self, forKey: "code")
            self.message = try values.decode(String.self, forKey: "message")
            self.param = try values.decodeIfPresent(String.self, forKey: "param")
            self.eventID = try values.decodeIfPresent(String.self, forKey: "event_id")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(type, forKey: "type")
            try values.encodeIfPresent(code, forKey: "code")
            try values.encode(message, forKey: "message")
            try values.encodeIfPresent(param, forKey: "param")
            try values.encodeIfPresent(eventID, forKey: "event_id")
        }
    }

    public init(eventID: String, type: `Type`, error: Error) {
        self.eventID = eventID
        self.type = type
        self.error = error
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.eventID = try values.decode(String.self, forKey: "event_id")
        self.type = try values.decode(`Type`.self, forKey: "type")
        self.error = try values.decode(Error.self, forKey: "error")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(eventID, forKey: "event_id")
        try values.encode(type, forKey: "type")
        try values.encode(error, forKey: "error")
    }
}
