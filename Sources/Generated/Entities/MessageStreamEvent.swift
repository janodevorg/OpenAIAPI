// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public enum MessageStreamEvent: Codable {
    case a(A)
    case b(B)
    case c(C)
    case d(D)
    case e(E)

    /// Occurs when a [message](/docs/api-reference/messages/object) is created.
    public struct A: Codable {
        public var event: Event
        /// The message object
        ///
        /// Represents a message within a [thread](/docs/api-reference/threads).
        public var data: MessageObject

        public enum Event: String, Codable, CaseIterable {
            case threadMessageCreated = "thread.message.created"
        }

        public init(event: Event, data: MessageObject) {
            self.event = event
            self.data = data
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.event = try values.decode(Event.self, forKey: "event")
            self.data = try values.decode(MessageObject.self, forKey: "data")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(event, forKey: "event")
            try values.encode(data, forKey: "data")
        }
    }

    /// Occurs when a [message](/docs/api-reference/messages/object) moves to an `in_progress` state.
    public struct B: Codable {
        public var event: Event
        /// The message object
        ///
        /// Represents a message within a [thread](/docs/api-reference/threads).
        public var data: MessageObject

        public enum Event: String, Codable, CaseIterable {
            case threadMessageInProgress = "thread.message.in_progress"
        }

        public init(event: Event, data: MessageObject) {
            self.event = event
            self.data = data
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.event = try values.decode(Event.self, forKey: "event")
            self.data = try values.decode(MessageObject.self, forKey: "data")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(event, forKey: "event")
            try values.encode(data, forKey: "data")
        }
    }

    /// Occurs when parts of a [Message](/docs/api-reference/messages/object) are being streamed.
    public struct C: Codable {
        public var event: Event
        /// Message delta object
        ///
        /// Represents a message delta i.e. any changed fields on a message during streaming.
        public var data: MessageDeltaObject

        public enum Event: String, Codable, CaseIterable {
            case threadMessageDelta = "thread.message.delta"
        }

        public init(event: Event, data: MessageDeltaObject) {
            self.event = event
            self.data = data
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.event = try values.decode(Event.self, forKey: "event")
            self.data = try values.decode(MessageDeltaObject.self, forKey: "data")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(event, forKey: "event")
            try values.encode(data, forKey: "data")
        }
    }

    /// Occurs when a [message](/docs/api-reference/messages/object) is completed.
    public struct D: Codable {
        public var event: Event
        /// The message object
        ///
        /// Represents a message within a [thread](/docs/api-reference/threads).
        public var data: MessageObject

        public enum Event: String, Codable, CaseIterable {
            case threadMessageCompleted = "thread.message.completed"
        }

        public init(event: Event, data: MessageObject) {
            self.event = event
            self.data = data
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.event = try values.decode(Event.self, forKey: "event")
            self.data = try values.decode(MessageObject.self, forKey: "data")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(event, forKey: "event")
            try values.encode(data, forKey: "data")
        }
    }

    /// Occurs when a [message](/docs/api-reference/messages/object) ends before it is completed.
    public struct E: Codable {
        public var event: Event
        /// The message object
        ///
        /// Represents a message within a [thread](/docs/api-reference/threads).
        public var data: MessageObject

        public enum Event: String, Codable, CaseIterable {
            case threadMessageIncomplete = "thread.message.incomplete"
        }

        public init(event: Event, data: MessageObject) {
            self.event = event
            self.data = data
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.event = try values.decode(Event.self, forKey: "event")
            self.data = try values.decode(MessageObject.self, forKey: "data")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(event, forKey: "event")
            try values.encode(data, forKey: "data")
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(A.self) {
            self = .a(value)
        } else if let value = try? container.decode(B.self) {
            self = .b(value)
        } else if let value = try? container.decode(C.self) {
            self = .c(value)
        } else if let value = try? container.decode(D.self) {
            self = .d(value)
        } else if let value = try? container.decode(E.self) {
            self = .e(value)
        } else {
            throw DecodingError.dataCorruptedError(
                in: container,
                debugDescription: "Data could not be decoded as any of the expected types (A, B, C, D, E)."
            )
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .a(let value): try container.encode(value)
        case .b(let value): try container.encode(value)
        case .c(let value): try container.encode(value)
        case .d(let value): try container.encode(value)
        case .e(let value): try container.encode(value)
        }
    }
}
