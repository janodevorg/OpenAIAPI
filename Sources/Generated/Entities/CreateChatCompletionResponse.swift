// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Represents a chat completion response returned by model, based on the provided input.
public struct CreateChatCompletionResponse: Codable {
    /// A unique identifier for the chat completion.
    public var id: String
    /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
    public var choices: [Choice]
    /// The Unix timestamp (in seconds) of when the chat completion was created.
    public var created: Int
    /// The model used for the chat completion.
    public var model: String
    /// The service tier used for processing the request. This field is only included if the `service_tier` parameter is specified in the request.
    ///
    /// Example: "scale"
    public var serviceTier: ServiceTier?
    /// This fingerprint represents the backend configuration that the model runs with.
    /// 
    /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
    public var systemFingerprint: String?
    /// The object type, which is always `chat.completion`.
    public var object: Object
    /// Usage statistics for the completion request.
    public var usage: CompletionUsage?

    public struct Choice: Codable {
        /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
        /// `length` if the maximum number of tokens specified in the request was reached,
        /// `content_filter` if content was omitted due to a flag from our content filters,
        /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
        public var finishReason: FinishReason
        /// The index of the choice in the list of choices.
        public var index: Int
        /// A chat completion message generated by the model.
        public var message: ChatCompletionResponseMessage
        /// Log probability information for the choice.
        public var logprobs: Logprobs?

        /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
        /// `length` if the maximum number of tokens specified in the request was reached,
        /// `content_filter` if content was omitted due to a flag from our content filters,
        /// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
        public enum FinishReason: String, Codable, CaseIterable {
            case stop
            case length
            case toolCalls = "tool_calls"
            case contentFilter = "content_filter"
            case functionCall = "function_call"
        }

        /// Log probability information for the choice.
        public struct Logprobs: Codable {
            /// A list of message content tokens with log probability information.
            public var content: [ChatCompletionTokenLogprob]?
            /// A list of message refusal tokens with log probability information.
            public var refusal: [ChatCompletionTokenLogprob]?

            public init(content: [ChatCompletionTokenLogprob]? = nil, refusal: [ChatCompletionTokenLogprob]? = nil) {
                self.content = content
                self.refusal = refusal
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.content = try values.decodeIfPresent([ChatCompletionTokenLogprob].self, forKey: "content")
                self.refusal = try values.decodeIfPresent([ChatCompletionTokenLogprob].self, forKey: "refusal")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(content, forKey: "content")
                try values.encodeIfPresent(refusal, forKey: "refusal")
            }
        }

        public init(finishReason: FinishReason, index: Int, message: ChatCompletionResponseMessage, logprobs: Logprobs? = nil) {
            self.finishReason = finishReason
            self.index = index
            self.message = message
            self.logprobs = logprobs
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.finishReason = try values.decode(FinishReason.self, forKey: "finish_reason")
            self.index = try values.decode(Int.self, forKey: "index")
            self.message = try values.decode(ChatCompletionResponseMessage.self, forKey: "message")
            self.logprobs = try values.decodeIfPresent(Logprobs.self, forKey: "logprobs")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(finishReason, forKey: "finish_reason")
            try values.encode(index, forKey: "index")
            try values.encode(message, forKey: "message")
            try values.encodeIfPresent(logprobs, forKey: "logprobs")
        }
    }

    /// The service tier used for processing the request. This field is only included if the `service_tier` parameter is specified in the request.
    ///
    /// Example: "scale"
    public enum ServiceTier: String, Codable, CaseIterable {
        case scale
        case `default`
    }

    /// The object type, which is always `chat.completion`.
    public enum Object: String, Codable, CaseIterable {
        case chatCompletion = "chat.completion"
    }

    public init(id: String, choices: [Choice], created: Int, model: String, serviceTier: ServiceTier? = nil, systemFingerprint: String? = nil, object: Object, usage: CompletionUsage? = nil) {
        self.id = id
        self.choices = choices
        self.created = created
        self.model = model
        self.serviceTier = serviceTier
        self.systemFingerprint = systemFingerprint
        self.object = object
        self.usage = usage
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.choices = try values.decode([Choice].self, forKey: "choices")
        self.created = try values.decode(Int.self, forKey: "created")
        self.model = try values.decode(String.self, forKey: "model")
        self.serviceTier = try values.decodeIfPresent(ServiceTier.self, forKey: "service_tier")
        self.systemFingerprint = try values.decodeIfPresent(String.self, forKey: "system_fingerprint")
        self.object = try values.decode(Object.self, forKey: "object")
        self.usage = try values.decodeIfPresent(CompletionUsage.self, forKey: "usage")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(choices, forKey: "choices")
        try values.encode(created, forKey: "created")
        try values.encode(model, forKey: "model")
        try values.encodeIfPresent(serviceTier, forKey: "service_tier")
        try values.encodeIfPresent(systemFingerprint, forKey: "system_fingerprint")
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(usage, forKey: "usage")
    }
}
