// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// A run on a thread
///
/// Represents an execution run on a [thread](/docs/api-reference/threads).
public struct RunObject: Codable {
    /// The identifier, which can be referenced in API endpoints.
    public var id: String
    /// The object type, which is always `thread.run`.
    public var object: Object
    /// The Unix timestamp (in seconds) for when the run was created.
    public var createdAt: Int
    /// The ID of the [thread](/docs/api-reference/threads) that was executed on as a part of this run.
    public var threadID: String
    /// The ID of the [assistant](/docs/api-reference/assistants) used for execution of this run.
    public var assistantID: String
    /// The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, `incomplete`, or `expired`.
    public var status: Status
    /// Details on the action required to continue the run. Will be `null` if no action is required.
    public var requiredAction: RequiredAction?
    /// The last error associated with this run. Will be `null` if there are no errors.
    public var lastError: LastError?
    /// The Unix timestamp (in seconds) for when the run will expire.
    public var expiresAt: Int?
    /// The Unix timestamp (in seconds) for when the run was started.
    public var startedAt: Int?
    /// The Unix timestamp (in seconds) for when the run was cancelled.
    public var cancelledAt: Int?
    /// The Unix timestamp (in seconds) for when the run failed.
    public var failedAt: Int?
    /// The Unix timestamp (in seconds) for when the run was completed.
    public var completedAt: Int?
    /// Details on why the run is incomplete. Will be `null` if the run is not incomplete.
    public var incompleteDetails: IncompleteDetails?
    /// The model that the [assistant](/docs/api-reference/assistants) used for this run.
    public var model: String
    /// The instructions that the [assistant](/docs/api-reference/assistants) used for this run.
    public var instructions: String
    /// The list of tools that the [assistant](/docs/api-reference/assistants) used for this run.
    public var tools: [Tool]
    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
    public var metadata: [String: AnyJSON]?
    /// Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.).
    public var usage: RunCompletionUsage?
    /// The sampling temperature used for this run. If not set, defaults to 1.
    public var temperature: Double?
    /// The nucleus sampling value used for this run. If not set, defaults to 1.
    public var topP: Double?
    /// The maximum number of prompt tokens specified to have been used over the course of the run.
    public var maxPromptTokens: Int?
    /// The maximum number of completion tokens specified to have been used over the course of the run.
    public var maxCompletionTokens: Int?
    /// Thread Truncation Controls
    ///
    /// Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run.
    public var truncationStrategy: TruncationObject
    /// Controls which (if any) tool is called by the model.
    /// `none` means the model will not call any tools and instead generates a message.
    /// `auto` is the default value and means the model can pick between generating a message or calling one or more tools.
    /// `required` means the model must call one or more tools before responding to the user.
    /// Specifying a particular tool like `{"type": "file_search"}` or `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
    public var toolChoice: AssistantsAPIToolChoiceOption
    /// Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
    public var isParallelToolCalls: Bool
    /// Specifies the format that the model must output. Compatible with [GPT-4o](/docs/models#gpt-4o), [GPT-4 Turbo](/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
    /// 
    /// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).
    /// 
    /// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
    /// 
    /// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
    public var responseFormat: AssistantsAPIResponseFormatOption

    /// The object type, which is always `thread.run`.
    public enum Object: String, Codable, CaseIterable {
        case threadRun = "thread.run"
    }

    /// The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, `incomplete`, or `expired`.
    public enum Status: String, Codable, CaseIterable {
        case queued
        case inProgress = "in_progress"
        case requiresAction = "requires_action"
        case cancelling
        case cancelled
        case failed
        case completed
        case incomplete
        case expired
    }

    /// Details on the action required to continue the run. Will be `null` if no action is required.
    public struct RequiredAction: Codable {
        /// For now, this is always `submit_tool_outputs`.
        public var type: `Type`
        /// Details on the tool outputs needed for this run to continue.
        public var submitToolOutputs: SubmitToolOutputs

        /// For now, this is always `submit_tool_outputs`.
        public enum `Type`: String, Codable, CaseIterable {
            case submitToolOutputs = "submit_tool_outputs"
        }

        /// Details on the tool outputs needed for this run to continue.
        public struct SubmitToolOutputs: Codable {
            /// A list of the relevant tool calls.
            public var toolCalls: [RunToolCallObject]

            public init(toolCalls: [RunToolCallObject]) {
                self.toolCalls = toolCalls
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.toolCalls = try values.decode([RunToolCallObject].self, forKey: "tool_calls")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(toolCalls, forKey: "tool_calls")
            }
        }

        public init(type: `Type`, submitToolOutputs: SubmitToolOutputs) {
            self.type = type
            self.submitToolOutputs = submitToolOutputs
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.type = try values.decode(`Type`.self, forKey: "type")
            self.submitToolOutputs = try values.decode(SubmitToolOutputs.self, forKey: "submit_tool_outputs")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(type, forKey: "type")
            try values.encode(submitToolOutputs, forKey: "submit_tool_outputs")
        }
    }

    /// The last error associated with this run. Will be `null` if there are no errors.
    public struct LastError: Codable {
        /// One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`.
        public var code: Code
        /// A human-readable description of the error.
        public var message: String

        /// One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`.
        public enum Code: String, Codable, CaseIterable {
            case serverError = "server_error"
            case rateLimitExceeded = "rate_limit_exceeded"
            case invalidPrompt = "invalid_prompt"
        }

        public init(code: Code, message: String) {
            self.code = code
            self.message = message
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.code = try values.decode(Code.self, forKey: "code")
            self.message = try values.decode(String.self, forKey: "message")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(code, forKey: "code")
            try values.encode(message, forKey: "message")
        }
    }

    /// Details on why the run is incomplete. Will be `null` if the run is not incomplete.
    public struct IncompleteDetails: Codable {
        /// The reason why the run is incomplete. This will point to which specific token limit was reached over the course of the run.
        public var reason: Reason?

        /// The reason why the run is incomplete. This will point to which specific token limit was reached over the course of the run.
        public enum Reason: String, Codable, CaseIterable {
            case maxCompletionTokens = "max_completion_tokens"
            case maxPromptTokens = "max_prompt_tokens"
        }

        public init(reason: Reason? = nil) {
            self.reason = reason
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.reason = try values.decodeIfPresent(Reason.self, forKey: "reason")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(reason, forKey: "reason")
        }
    }

    public enum Tool: Codable {
        case assistantToolsCode(AssistantToolsCode)
        case assistantToolsFileSearch(AssistantToolsFileSearch)
        case assistantToolsFunction(AssistantToolsFunction)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(AssistantToolsCode.self) {
                self = .assistantToolsCode(value)
            } else if let value = try? container.decode(AssistantToolsFileSearch.self) {
                self = .assistantToolsFileSearch(value)
            } else if let value = try? container.decode(AssistantToolsFunction.self) {
                self = .assistantToolsFunction(value)
            } else {
                throw DecodingError.dataCorruptedError(
                    in: container,
                    debugDescription: "Data could not be decoded as any of the expected types (AssistantToolsCode, AssistantToolsFileSearch, AssistantToolsFunction)."
                )
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .assistantToolsCode(let value): try container.encode(value)
            case .assistantToolsFileSearch(let value): try container.encode(value)
            case .assistantToolsFunction(let value): try container.encode(value)
            }
        }
    }

    public init(id: String, object: Object, createdAt: Int, threadID: String, assistantID: String, status: Status, requiredAction: RequiredAction? = nil, lastError: LastError? = nil, expiresAt: Int? = nil, startedAt: Int? = nil, cancelledAt: Int? = nil, failedAt: Int? = nil, completedAt: Int? = nil, incompleteDetails: IncompleteDetails? = nil, model: String, instructions: String, tools: [Tool], metadata: [String: AnyJSON]? = nil, usage: RunCompletionUsage? = nil, temperature: Double? = nil, topP: Double? = nil, maxPromptTokens: Int? = nil, maxCompletionTokens: Int? = nil, truncationStrategy: TruncationObject, toolChoice: AssistantsAPIToolChoiceOption, isParallelToolCalls: Bool, responseFormat: AssistantsAPIResponseFormatOption) {
        self.id = id
        self.object = object
        self.createdAt = createdAt
        self.threadID = threadID
        self.assistantID = assistantID
        self.status = status
        self.requiredAction = requiredAction
        self.lastError = lastError
        self.expiresAt = expiresAt
        self.startedAt = startedAt
        self.cancelledAt = cancelledAt
        self.failedAt = failedAt
        self.completedAt = completedAt
        self.incompleteDetails = incompleteDetails
        self.model = model
        self.instructions = instructions
        self.tools = tools
        self.metadata = metadata
        self.usage = usage
        self.temperature = temperature
        self.topP = topP
        self.maxPromptTokens = maxPromptTokens
        self.maxCompletionTokens = maxCompletionTokens
        self.truncationStrategy = truncationStrategy
        self.toolChoice = toolChoice
        self.isParallelToolCalls = isParallelToolCalls
        self.responseFormat = responseFormat
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.object = try values.decode(Object.self, forKey: "object")
        self.createdAt = try values.decode(Int.self, forKey: "created_at")
        self.threadID = try values.decode(String.self, forKey: "thread_id")
        self.assistantID = try values.decode(String.self, forKey: "assistant_id")
        self.status = try values.decode(Status.self, forKey: "status")
        self.requiredAction = try values.decodeIfPresent(RequiredAction.self, forKey: "required_action")
        self.lastError = try values.decodeIfPresent(LastError.self, forKey: "last_error")
        self.expiresAt = try values.decodeIfPresent(Int.self, forKey: "expires_at")
        self.startedAt = try values.decodeIfPresent(Int.self, forKey: "started_at")
        self.cancelledAt = try values.decodeIfPresent(Int.self, forKey: "cancelled_at")
        self.failedAt = try values.decodeIfPresent(Int.self, forKey: "failed_at")
        self.completedAt = try values.decodeIfPresent(Int.self, forKey: "completed_at")
        self.incompleteDetails = try values.decodeIfPresent(IncompleteDetails.self, forKey: "incomplete_details")
        self.model = try values.decode(String.self, forKey: "model")
        self.instructions = try values.decode(String.self, forKey: "instructions")
        self.tools = try values.decode([Tool].self, forKey: "tools")
        self.metadata = try values.decodeIfPresent([String: AnyJSON].self, forKey: "metadata")
        self.usage = try values.decodeIfPresent(RunCompletionUsage.self, forKey: "usage")
        self.temperature = try values.decodeIfPresent(Double.self, forKey: "temperature")
        self.topP = try values.decodeIfPresent(Double.self, forKey: "top_p")
        self.maxPromptTokens = try values.decodeIfPresent(Int.self, forKey: "max_prompt_tokens")
        self.maxCompletionTokens = try values.decodeIfPresent(Int.self, forKey: "max_completion_tokens")
        self.truncationStrategy = try values.decode(TruncationObject.self, forKey: "truncation_strategy")
        self.toolChoice = try values.decode(AssistantsAPIToolChoiceOption.self, forKey: "tool_choice")
        self.isParallelToolCalls = try values.decode(Bool.self, forKey: "parallel_tool_calls")
        self.responseFormat = try values.decode(AssistantsAPIResponseFormatOption.self, forKey: "response_format")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(object, forKey: "object")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(threadID, forKey: "thread_id")
        try values.encode(assistantID, forKey: "assistant_id")
        try values.encode(status, forKey: "status")
        try values.encodeIfPresent(requiredAction, forKey: "required_action")
        try values.encodeIfPresent(lastError, forKey: "last_error")
        try values.encodeIfPresent(expiresAt, forKey: "expires_at")
        try values.encodeIfPresent(startedAt, forKey: "started_at")
        try values.encodeIfPresent(cancelledAt, forKey: "cancelled_at")
        try values.encodeIfPresent(failedAt, forKey: "failed_at")
        try values.encodeIfPresent(completedAt, forKey: "completed_at")
        try values.encodeIfPresent(incompleteDetails, forKey: "incomplete_details")
        try values.encode(model, forKey: "model")
        try values.encode(instructions, forKey: "instructions")
        try values.encode(tools, forKey: "tools")
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encodeIfPresent(usage, forKey: "usage")
        try values.encodeIfPresent(temperature, forKey: "temperature")
        try values.encodeIfPresent(topP, forKey: "top_p")
        try values.encodeIfPresent(maxPromptTokens, forKey: "max_prompt_tokens")
        try values.encodeIfPresent(maxCompletionTokens, forKey: "max_completion_tokens")
        try values.encode(truncationStrategy, forKey: "truncation_strategy")
        try values.encode(toolChoice, forKey: "tool_choice")
        try values.encode(isParallelToolCalls, forKey: "parallel_tool_calls")
        try values.encode(responseFormat, forKey: "response_format")
    }
}
