// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct Batch: Codable {
    public var id: String
    /// The object type, which is always `batch`.
    public var object: Object
    /// The OpenAI API endpoint used by the batch.
    public var endpoint: String
    public var errors: Errors?
    /// The ID of the input file for the batch.
    public var inputFileID: String
    /// The time frame within which the batch should be processed.
    public var completionWindow: String
    /// The current status of the batch.
    public var status: Status
    /// The ID of the file containing the outputs of successfully executed requests.
    public var outputFileID: String?
    /// The ID of the file containing the outputs of requests with errors.
    public var errorFileID: String?
    /// The Unix timestamp (in seconds) for when the batch was created.
    public var createdAt: Int
    /// The Unix timestamp (in seconds) for when the batch started processing.
    public var inProgressAt: Int?
    /// The Unix timestamp (in seconds) for when the batch will expire.
    public var expiresAt: Int?
    /// The Unix timestamp (in seconds) for when the batch started finalizing.
    public var finalizingAt: Int?
    /// The Unix timestamp (in seconds) for when the batch was completed.
    public var completedAt: Int?
    /// The Unix timestamp (in seconds) for when the batch failed.
    public var failedAt: Int?
    /// The Unix timestamp (in seconds) for when the batch expired.
    public var expiredAt: Int?
    /// The Unix timestamp (in seconds) for when the batch started cancelling.
    public var cancellingAt: Int?
    /// The Unix timestamp (in seconds) for when the batch was cancelled.
    public var cancelledAt: Int?
    /// The request counts for different statuses within the batch.
    public var requestCounts: RequestCounts?
    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
    public var metadata: [String: AnyJSON]?

    /// The object type, which is always `batch`.
    public enum Object: String, Codable, CaseIterable {
        case batch
    }

    public struct Errors: Codable {
        /// The object type, which is always `list`.
        public var object: String?
        public var data: [Datum]?

        public struct Datum: Codable {
            /// An error code identifying the error type.
            public var code: String?
            /// A human-readable message providing more details about the error.
            public var message: String?
            /// The name of the parameter that caused the error, if applicable.
            public var param: String?
            /// The line number of the input file where the error occurred, if applicable.
            public var line: Int?

            public init(code: String? = nil, message: String? = nil, param: String? = nil, line: Int? = nil) {
                self.code = code
                self.message = message
                self.param = param
                self.line = line
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.code = try values.decodeIfPresent(String.self, forKey: "code")
                self.message = try values.decodeIfPresent(String.self, forKey: "message")
                self.param = try values.decodeIfPresent(String.self, forKey: "param")
                self.line = try values.decodeIfPresent(Int.self, forKey: "line")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(code, forKey: "code")
                try values.encodeIfPresent(message, forKey: "message")
                try values.encodeIfPresent(param, forKey: "param")
                try values.encodeIfPresent(line, forKey: "line")
            }
        }

        public init(object: String? = nil, data: [Datum]? = nil) {
            self.object = object
            self.data = data
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.object = try values.decodeIfPresent(String.self, forKey: "object")
            self.data = try values.decodeIfPresent([Datum].self, forKey: "data")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(object, forKey: "object")
            try values.encodeIfPresent(data, forKey: "data")
        }
    }

    /// The current status of the batch.
    public enum Status: String, Codable, CaseIterable {
        case validating
        case failed
        case inProgress = "in_progress"
        case finalizing
        case completed
        case expired
        case cancelling
        case cancelled
    }

    /// The request counts for different statuses within the batch.
    public struct RequestCounts: Codable {
        /// Total number of requests in the batch.
        public var total: Int
        /// Number of requests that have been completed successfully.
        public var completed: Int
        /// Number of requests that have failed.
        public var failed: Int

        public init(total: Int, completed: Int, failed: Int) {
            self.total = total
            self.completed = completed
            self.failed = failed
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.total = try values.decode(Int.self, forKey: "total")
            self.completed = try values.decode(Int.self, forKey: "completed")
            self.failed = try values.decode(Int.self, forKey: "failed")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(total, forKey: "total")
            try values.encode(completed, forKey: "completed")
            try values.encode(failed, forKey: "failed")
        }
    }

    public init(id: String, object: Object, endpoint: String, errors: Errors? = nil, inputFileID: String, completionWindow: String, status: Status, outputFileID: String? = nil, errorFileID: String? = nil, createdAt: Int, inProgressAt: Int? = nil, expiresAt: Int? = nil, finalizingAt: Int? = nil, completedAt: Int? = nil, failedAt: Int? = nil, expiredAt: Int? = nil, cancellingAt: Int? = nil, cancelledAt: Int? = nil, requestCounts: RequestCounts? = nil, metadata: [String: AnyJSON]? = nil) {
        self.id = id
        self.object = object
        self.endpoint = endpoint
        self.errors = errors
        self.inputFileID = inputFileID
        self.completionWindow = completionWindow
        self.status = status
        self.outputFileID = outputFileID
        self.errorFileID = errorFileID
        self.createdAt = createdAt
        self.inProgressAt = inProgressAt
        self.expiresAt = expiresAt
        self.finalizingAt = finalizingAt
        self.completedAt = completedAt
        self.failedAt = failedAt
        self.expiredAt = expiredAt
        self.cancellingAt = cancellingAt
        self.cancelledAt = cancelledAt
        self.requestCounts = requestCounts
        self.metadata = metadata
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.object = try values.decode(Object.self, forKey: "object")
        self.endpoint = try values.decode(String.self, forKey: "endpoint")
        self.errors = try values.decodeIfPresent(Errors.self, forKey: "errors")
        self.inputFileID = try values.decode(String.self, forKey: "input_file_id")
        self.completionWindow = try values.decode(String.self, forKey: "completion_window")
        self.status = try values.decode(Status.self, forKey: "status")
        self.outputFileID = try values.decodeIfPresent(String.self, forKey: "output_file_id")
        self.errorFileID = try values.decodeIfPresent(String.self, forKey: "error_file_id")
        self.createdAt = try values.decode(Int.self, forKey: "created_at")
        self.inProgressAt = try values.decodeIfPresent(Int.self, forKey: "in_progress_at")
        self.expiresAt = try values.decodeIfPresent(Int.self, forKey: "expires_at")
        self.finalizingAt = try values.decodeIfPresent(Int.self, forKey: "finalizing_at")
        self.completedAt = try values.decodeIfPresent(Int.self, forKey: "completed_at")
        self.failedAt = try values.decodeIfPresent(Int.self, forKey: "failed_at")
        self.expiredAt = try values.decodeIfPresent(Int.self, forKey: "expired_at")
        self.cancellingAt = try values.decodeIfPresent(Int.self, forKey: "cancelling_at")
        self.cancelledAt = try values.decodeIfPresent(Int.self, forKey: "cancelled_at")
        self.requestCounts = try values.decodeIfPresent(RequestCounts.self, forKey: "request_counts")
        self.metadata = try values.decodeIfPresent([String: AnyJSON].self, forKey: "metadata")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(object, forKey: "object")
        try values.encode(endpoint, forKey: "endpoint")
        try values.encodeIfPresent(errors, forKey: "errors")
        try values.encode(inputFileID, forKey: "input_file_id")
        try values.encode(completionWindow, forKey: "completion_window")
        try values.encode(status, forKey: "status")
        try values.encodeIfPresent(outputFileID, forKey: "output_file_id")
        try values.encodeIfPresent(errorFileID, forKey: "error_file_id")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(inProgressAt, forKey: "in_progress_at")
        try values.encodeIfPresent(expiresAt, forKey: "expires_at")
        try values.encodeIfPresent(finalizingAt, forKey: "finalizing_at")
        try values.encodeIfPresent(completedAt, forKey: "completed_at")
        try values.encodeIfPresent(failedAt, forKey: "failed_at")
        try values.encodeIfPresent(expiredAt, forKey: "expired_at")
        try values.encodeIfPresent(cancellingAt, forKey: "cancelling_at")
        try values.encodeIfPresent(cancelledAt, forKey: "cancelled_at")
        try values.encodeIfPresent(requestCounts, forKey: "request_counts")
        try values.encodeIfPresent(metadata, forKey: "metadata")
    }
}
