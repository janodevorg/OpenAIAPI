// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// The message object
///
/// Represents a message within a [thread](/docs/api-reference/threads).
public struct MessageObject: Codable {
    /// The identifier, which can be referenced in API endpoints.
    public var id: String
    /// The object type, which is always `thread.message`.
    public var object: Object
    /// The Unix timestamp (in seconds) for when the message was created.
    public var createdAt: Int
    /// The [thread](/docs/api-reference/threads) ID that this message belongs to.
    public var threadID: String
    /// The status of the message, which can be either `in_progress`, `incomplete`, or `completed`.
    public var status: Status
    /// On an incomplete message, details about why the message is incomplete.
    public var incompleteDetails: IncompleteDetails?
    /// The Unix timestamp (in seconds) for when the message was completed.
    public var completedAt: Int?
    /// The Unix timestamp (in seconds) for when the message was marked as incomplete.
    public var incompleteAt: Int?
    /// The entity that produced the message. One of `user` or `assistant`.
    public var role: Role
    /// The content of the message in array of text and/or images.
    public var content: [ContentItem]
    /// If applicable, the ID of the [assistant](/docs/api-reference/assistants) that authored this message.
    public var assistantID: String?
    /// The ID of the [run](/docs/api-reference/runs) associated with the creation of this message. Value is `null` when messages are created manually using the create message or create thread endpoints.
    public var runID: String?
    /// A list of files attached to the message, and the tools they were added to.
    public var attachments: [Attachmants]?
    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
    public var metadata: [String: AnyJSON]?

    /// The object type, which is always `thread.message`.
    public enum Object: String, Codable, CaseIterable {
        case threadMessage = "thread.message"
    }

    /// The status of the message, which can be either `in_progress`, `incomplete`, or `completed`.
    public enum Status: String, Codable, CaseIterable {
        case inProgress = "in_progress"
        case incomplete
        case completed
    }

    /// On an incomplete message, details about why the message is incomplete.
    public struct IncompleteDetails: Codable {
        /// The reason the message is incomplete.
        public var reason: Reason

        /// The reason the message is incomplete.
        public enum Reason: String, Codable, CaseIterable {
            case contentFilter = "content_filter"
            case maxTokens = "max_tokens"
            case runCancelled = "run_cancelled"
            case runExpired = "run_expired"
            case runFailed = "run_failed"
        }

        public init(reason: Reason) {
            self.reason = reason
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.reason = try values.decode(Reason.self, forKey: "reason")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(reason, forKey: "reason")
        }
    }

    /// The entity that produced the message. One of `user` or `assistant`.
    public enum Role: String, Codable, CaseIterable {
        case user
        case assistant
    }

    public enum ContentItem: Codable {
        case messageContentImageFileObject(MessageContentImageFileObject)
        case messageContentImageURLObject(MessageContentImageURLObject)
        case messageContentTextObject(MessageContentTextObject)
        case messageContentRefusalObject(MessageContentRefusalObject)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(MessageContentImageFileObject.self) {
                self = .messageContentImageFileObject(value)
            } else if let value = try? container.decode(MessageContentImageURLObject.self) {
                self = .messageContentImageURLObject(value)
            } else if let value = try? container.decode(MessageContentTextObject.self) {
                self = .messageContentTextObject(value)
            } else if let value = try? container.decode(MessageContentRefusalObject.self) {
                self = .messageContentRefusalObject(value)
            } else {
                throw DecodingError.dataCorruptedError(
                    in: container,
                    debugDescription: "Data could not be decoded as any of the expected types (MessageContentImageFileObject, MessageContentImageURLObject, MessageContentTextObject, MessageContentRefusalObject)."
                )
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .messageContentImageFileObject(let value): try container.encode(value)
            case .messageContentImageURLObject(let value): try container.encode(value)
            case .messageContentTextObject(let value): try container.encode(value)
            case .messageContentRefusalObject(let value): try container.encode(value)
            }
        }
    }

    public struct Attachmants: Codable {
        /// The ID of the file to attach to the message.
        public var fileID: String?
        /// The tools to add this file to.
        public var tools: [Tool]?

        public enum Tool: Codable {
            case assistantToolsCode(AssistantToolsCode)
            case assistantToolsFileSearchTypeOnly(AssistantToolsFileSearchTypeOnly)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(AssistantToolsCode.self) {
                    self = .assistantToolsCode(value)
                } else if let value = try? container.decode(AssistantToolsFileSearchTypeOnly.self) {
                    self = .assistantToolsFileSearchTypeOnly(value)
                } else {
                    throw DecodingError.dataCorruptedError(
                        in: container,
                        debugDescription: "Data could not be decoded as any of the expected types (AssistantToolsCode, AssistantToolsFileSearchTypeOnly)."
                    )
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .assistantToolsCode(let value): try container.encode(value)
                case .assistantToolsFileSearchTypeOnly(let value): try container.encode(value)
                }
            }
        }

        public init(fileID: String? = nil, tools: [Tool]? = nil) {
            self.fileID = fileID
            self.tools = tools
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.fileID = try values.decodeIfPresent(String.self, forKey: "file_id")
            self.tools = try values.decodeIfPresent([Tool].self, forKey: "tools")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(fileID, forKey: "file_id")
            try values.encodeIfPresent(tools, forKey: "tools")
        }
    }

    public init(id: String, object: Object, createdAt: Int, threadID: String, status: Status, incompleteDetails: IncompleteDetails? = nil, completedAt: Int? = nil, incompleteAt: Int? = nil, role: Role, content: [ContentItem], assistantID: String? = nil, runID: String? = nil, attachments: [Attachmants]? = nil, metadata: [String: AnyJSON]? = nil) {
        self.id = id
        self.object = object
        self.createdAt = createdAt
        self.threadID = threadID
        self.status = status
        self.incompleteDetails = incompleteDetails
        self.completedAt = completedAt
        self.incompleteAt = incompleteAt
        self.role = role
        self.content = content
        self.assistantID = assistantID
        self.runID = runID
        self.attachments = attachments
        self.metadata = metadata
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.object = try values.decode(Object.self, forKey: "object")
        self.createdAt = try values.decode(Int.self, forKey: "created_at")
        self.threadID = try values.decode(String.self, forKey: "thread_id")
        self.status = try values.decode(Status.self, forKey: "status")
        self.incompleteDetails = try values.decodeIfPresent(IncompleteDetails.self, forKey: "incomplete_details")
        self.completedAt = try values.decodeIfPresent(Int.self, forKey: "completed_at")
        self.incompleteAt = try values.decodeIfPresent(Int.self, forKey: "incomplete_at")
        self.role = try values.decode(Role.self, forKey: "role")
        self.content = try values.decode([ContentItem].self, forKey: "content")
        self.assistantID = try values.decodeIfPresent(String.self, forKey: "assistant_id")
        self.runID = try values.decodeIfPresent(String.self, forKey: "run_id")
        self.attachments = try values.decodeIfPresent([Attachmants].self, forKey: "attachments")
        self.metadata = try values.decodeIfPresent([String: AnyJSON].self, forKey: "metadata")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(object, forKey: "object")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(threadID, forKey: "thread_id")
        try values.encode(status, forKey: "status")
        try values.encodeIfPresent(incompleteDetails, forKey: "incomplete_details")
        try values.encodeIfPresent(completedAt, forKey: "completed_at")
        try values.encodeIfPresent(incompleteAt, forKey: "incomplete_at")
        try values.encode(role, forKey: "role")
        try values.encode(content, forKey: "content")
        try values.encodeIfPresent(assistantID, forKey: "assistant_id")
        try values.encodeIfPresent(runID, forKey: "run_id")
        try values.encodeIfPresent(attachments, forKey: "attachments")
        try values.encodeIfPresent(metadata, forKey: "metadata")
    }
}
