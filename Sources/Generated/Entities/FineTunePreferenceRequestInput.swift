// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// The per-line training example of a fine-tuning input file for chat models using the dpo method.
public struct FineTunePreferenceRequestInput: Codable {
    public var input: Input?
    /// The preferred completion message for the output.
    public var preferredCompletion: [ChatCompletionRequestAssistantMessage]?
    /// The non-preferred completion message for the output.
    public var nonPreferredCompletion: [ChatCompletionRequestAssistantMessage]?

    public struct Input: Codable {
        public var messages: [Message]?
        /// A list of tools the model may generate JSON inputs for.
        public var tools: [ChatCompletionTool]?
        /// Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
        public var isParallelToolCalls: Bool

        public enum Message: Codable {
            case chatCompletionRequestSystemMessage(ChatCompletionRequestSystemMessage)
            case chatCompletionRequestUserMessage(ChatCompletionRequestUserMessage)
            case fineTuneChatCompletionRequestAssistantMessage(FineTuneChatCompletionRequestAssistantMessage)
            case chatCompletionRequestToolMessage(ChatCompletionRequestToolMessage)
            case chatCompletionRequestFunctionMessage(ChatCompletionRequestFunctionMessage)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(ChatCompletionRequestSystemMessage.self) {
                    self = .chatCompletionRequestSystemMessage(value)
                } else if let value = try? container.decode(ChatCompletionRequestUserMessage.self) {
                    self = .chatCompletionRequestUserMessage(value)
                } else if let value = try? container.decode(FineTuneChatCompletionRequestAssistantMessage.self) {
                    self = .fineTuneChatCompletionRequestAssistantMessage(value)
                } else if let value = try? container.decode(ChatCompletionRequestToolMessage.self) {
                    self = .chatCompletionRequestToolMessage(value)
                } else if let value = try? container.decode(ChatCompletionRequestFunctionMessage.self) {
                    self = .chatCompletionRequestFunctionMessage(value)
                } else {
                    throw DecodingError.dataCorruptedError(
                        in: container,
                        debugDescription: "Data could not be decoded as any of the expected types (ChatCompletionRequestSystemMessage, ChatCompletionRequestUserMessage, FineTuneChatCompletionRequestAssistantMessage, ChatCompletionRequestToolMessage, ChatCompletionRequestFunctionMessage)."
                    )
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .chatCompletionRequestSystemMessage(let value): try container.encode(value)
                case .chatCompletionRequestUserMessage(let value): try container.encode(value)
                case .fineTuneChatCompletionRequestAssistantMessage(let value): try container.encode(value)
                case .chatCompletionRequestToolMessage(let value): try container.encode(value)
                case .chatCompletionRequestFunctionMessage(let value): try container.encode(value)
                }
            }
        }

        public init(messages: [Message]? = nil, tools: [ChatCompletionTool]? = nil, isParallelToolCalls: Bool? = nil) {
            self.messages = messages
            self.tools = tools
            self.isParallelToolCalls = isParallelToolCalls ?? true
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.messages = try values.decodeIfPresent([Message].self, forKey: "messages")
            self.tools = try values.decodeIfPresent([ChatCompletionTool].self, forKey: "tools")
            self.isParallelToolCalls = try values.decodeIfPresent(Bool.self, forKey: "parallel_tool_calls") ?? true
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(messages, forKey: "messages")
            try values.encodeIfPresent(tools, forKey: "tools")
            try values.encodeIfPresent(isParallelToolCalls, forKey: "parallel_tool_calls")
        }
    }

    public init(input: Input? = nil, preferredCompletion: [ChatCompletionRequestAssistantMessage]? = nil, nonPreferredCompletion: [ChatCompletionRequestAssistantMessage]? = nil) {
        self.input = input
        self.preferredCompletion = preferredCompletion
        self.nonPreferredCompletion = nonPreferredCompletion
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.input = try values.decodeIfPresent(Input.self, forKey: "input")
        self.preferredCompletion = try values.decodeIfPresent([ChatCompletionRequestAssistantMessage].self, forKey: "preferred_completion")
        self.nonPreferredCompletion = try values.decodeIfPresent([ChatCompletionRequestAssistantMessage].self, forKey: "non_preferred_completion")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(input, forKey: "input")
        try values.encodeIfPresent(preferredCompletion, forKey: "preferred_completion")
        try values.encodeIfPresent(nonPreferredCompletion, forKey: "non_preferred_completion")
    }
}
