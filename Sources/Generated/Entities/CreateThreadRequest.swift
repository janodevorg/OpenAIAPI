// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct CreateThreadRequest: Codable {
    /// A list of [messages](/docs/api-reference/messages) to start the thread with.
    public var messages: [CreateMessageRequest]?
    /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
    public var toolResources: ToolResources?
    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
    public var metadata: [String: AnyJSON]?

    /// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
    public struct ToolResources: Codable {
        public var codeInterpreter: CodeInterpreter?
        public var fileSearch: FileSearch?

        public struct CodeInterpreter: Codable {
            /// A list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.
            public var fileIDs: [String]?

            public init(fileIDs: [String]? = nil) {
                self.fileIDs = fileIDs
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.fileIDs = try values.decodeIfPresent([String].self, forKey: "file_ids")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(fileIDs, forKey: "file_ids")
            }
        }

        public enum FileSearch: Codable {
            case fileSearchWithIDs(FileSearchWithIDs)
            case fileSearchWithStores(FileSearchWithStores)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(FileSearchWithIDs.self) {
                    self = .fileSearchWithIDs(value)
                } else if let value = try? container.decode(FileSearchWithStores.self) {
                    self = .fileSearchWithStores(value)
                } else {
                    throw DecodingError.dataCorruptedError(
                        in: container,
                        debugDescription: "Data could not be decoded as any of the expected types (FileSearchWithIDs, FileSearchWithStores)."
                    )
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .fileSearchWithIDs(let value): try container.encode(value)
                case .fileSearchWithStores(let value): try container.encode(value)
                }
            }
        }

        public init(codeInterpreter: CodeInterpreter? = nil, fileSearch: FileSearch? = nil) {
            self.codeInterpreter = codeInterpreter
            self.fileSearch = fileSearch
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.codeInterpreter = try values.decodeIfPresent(CodeInterpreter.self, forKey: "code_interpreter")
            self.fileSearch = try values.decodeIfPresent(FileSearch.self, forKey: "file_search")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(codeInterpreter, forKey: "code_interpreter")
            try values.encodeIfPresent(fileSearch, forKey: "file_search")
        }
    }

    public init(messages: [CreateMessageRequest]? = nil, toolResources: ToolResources? = nil, metadata: [String: AnyJSON]? = nil) {
        self.messages = messages
        self.toolResources = toolResources
        self.metadata = metadata
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.messages = try values.decodeIfPresent([CreateMessageRequest].self, forKey: "messages")
        self.toolResources = try values.decodeIfPresent(ToolResources.self, forKey: "tool_resources")
        self.metadata = try values.decodeIfPresent([String: AnyJSON].self, forKey: "metadata")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(messages, forKey: "messages")
        try values.encodeIfPresent(toolResources, forKey: "tool_resources")
        try values.encodeIfPresent(metadata, forKey: "metadata")
    }
}
