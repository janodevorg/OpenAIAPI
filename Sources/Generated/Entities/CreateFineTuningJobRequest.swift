// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct CreateFineTuningJobRequest: Codable {
    /// The name of the model to fine-tune. You can select one of the
    /// [supported models](/docs/guides/fine-tuning#which-models-can-be-fine-tuned).
    ///
    /// Example: "gpt-4o-mini"
    public var model: Model
    /// The ID of an uploaded file that contains training data.
    /// 
    /// See [upload file](/docs/api-reference/files/create) for how to upload a file.
    /// 
    /// Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.
    /// 
    /// The contents of the file should differ depending on if the model uses the [chat](/docs/api-reference/fine-tuning/chat-input), [completions](/docs/api-reference/fine-tuning/completions-input) format, or if the fine-tuning method uses the [preference](/docs/api-reference/fine-tuning/preference-input) format.
    /// 
    /// See the [fine-tuning guide](/docs/guides/fine-tuning) for more details.
    ///
    /// Example: "file-abc123"
    public var trainingFile: String
    /// The hyperparameters used for the fine-tuning job.
    /// This value is now deprecated in favor of `method`, and should be passed in under the `method` parameter.
    ///
    /// - warning: Deprecated.
    public var hyperparameters: Hyperparameters?
    /// A string of up to 64 characters that will be added to your fine-tuned model name.
    /// 
    /// For example, a `suffix` of "custom-model-name" would produce a model name like `ft:gpt-4o-mini:openai:custom-model-name:7p4lURel`.
    public var suffix: String?
    /// The ID of an uploaded file that contains validation data.
    /// 
    /// If you provide this file, the data is used to generate validation
    /// metrics periodically during fine-tuning. These metrics can be viewed in
    /// the fine-tuning results file.
    /// The same data should not be present in both train and validation files.
    /// 
    /// Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.
    /// 
    /// See the [fine-tuning guide](/docs/guides/fine-tuning) for more details.
    ///
    /// Example: "file-abc123"
    public var validationFile: String?
    /// A list of integrations to enable for your fine-tuning job.
    public var integrations: [Integration]?
    /// The seed controls the reproducibility of the job. Passing in the same seed and job parameters should produce the same results, but may differ in rare cases.
    /// If a seed is not specified, one will be generated for you.
    ///
    /// Example: 42
    public var seed: Int?
    /// The method used for fine-tuning.
    public var method: FineTuneMethod?

    /// The name of the model to fine-tune. You can select one of the
    /// [supported models](/docs/guides/fine-tuning#which-models-can-be-fine-tuned).
    ///
    /// Example: "gpt-4o-mini"
    public struct Model: Codable {
        public var string: String?
        public var object: Object?

        public enum Object: String, Codable, CaseIterable {
            case babbage002 = "babbage-002"
            case davinci002 = "davinci-002"
            case gpt35Turbo = "gpt-3.5-turbo"
            case gpt4oMini = "gpt-4o-mini"
        }

        public init(string: String? = nil, object: Object? = nil) {
            self.string = string
            self.object = object
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.object = try? container.decode(Object.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = object { try container.encode(value) }
        }
    }

    /// The hyperparameters used for the fine-tuning job.
    /// This value is now deprecated in favor of `method`, and should be passed in under the `method` parameter.
    @available(*, deprecated, message: "Deprecated")
    public struct Hyperparameters: Codable {
        /// Number of examples in each batch. A larger batch size means that model parameters
        /// are updated less frequently, but with lower variance.
        public var batchSize: BatchSize?
        /// Scaling factor for the learning rate. A smaller learning rate may be useful to avoid
        /// overfitting.
        public var learningRateMultiplier: LearningRateMultiplier?
        /// The number of epochs to train the model for. An epoch refers to one full cycle
        /// through the training dataset.
        public var nEpochs: NEpochs?

        /// Number of examples in each batch. A larger batch size means that model parameters
        /// are updated less frequently, but with lower variance.
        public enum BatchSize: Codable {
            case object(Object)
            case int(Int)

            public enum Object: String, Codable, CaseIterable {
                case auto
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(Object.self) {
                    self = .object(value)
                } else if let value = try? container.decode(Int.self) {
                    self = .int(value)
                } else {
                    throw DecodingError.dataCorruptedError(
                        in: container,
                        debugDescription: "Data could not be decoded as any of the expected types (Object, Int)."
                    )
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .object(let value): try container.encode(value)
                case .int(let value): try container.encode(value)
                }
            }
        }

        /// Scaling factor for the learning rate. A smaller learning rate may be useful to avoid
        /// overfitting.
        public enum LearningRateMultiplier: Codable {
            case object(Object)
            case double(Double)

            public enum Object: String, Codable, CaseIterable {
                case auto
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(Object.self) {
                    self = .object(value)
                } else if let value = try? container.decode(Double.self) {
                    self = .double(value)
                } else {
                    throw DecodingError.dataCorruptedError(
                        in: container,
                        debugDescription: "Data could not be decoded as any of the expected types (Object, Double)."
                    )
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .object(let value): try container.encode(value)
                case .double(let value): try container.encode(value)
                }
            }
        }

        /// The number of epochs to train the model for. An epoch refers to one full cycle
        /// through the training dataset.
        public enum NEpochs: Codable {
            case object(Object)
            case int(Int)

            public enum Object: String, Codable, CaseIterable {
                case auto
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(Object.self) {
                    self = .object(value)
                } else if let value = try? container.decode(Int.self) {
                    self = .int(value)
                } else {
                    throw DecodingError.dataCorruptedError(
                        in: container,
                        debugDescription: "Data could not be decoded as any of the expected types (Object, Int)."
                    )
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .object(let value): try container.encode(value)
                case .int(let value): try container.encode(value)
                }
            }
        }

        public init(batchSize: BatchSize? = nil, learningRateMultiplier: LearningRateMultiplier? = nil, nEpochs: NEpochs? = nil) {
            self.batchSize = batchSize
            self.learningRateMultiplier = learningRateMultiplier
            self.nEpochs = nEpochs
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.batchSize = try values.decodeIfPresent(BatchSize.self, forKey: "batch_size")
            self.learningRateMultiplier = try values.decodeIfPresent(LearningRateMultiplier.self, forKey: "learning_rate_multiplier")
            self.nEpochs = try values.decodeIfPresent(NEpochs.self, forKey: "n_epochs")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(batchSize, forKey: "batch_size")
            try values.encodeIfPresent(learningRateMultiplier, forKey: "learning_rate_multiplier")
            try values.encodeIfPresent(nEpochs, forKey: "n_epochs")
        }
    }

    public struct Integration: Codable {
        /// The type of integration to enable. Currently, only "wandb" (Weights and Biases) is supported.
        public var type: `Type`
        /// The settings for your integration with Weights and Biases. This payload specifies the project that
        /// metrics will be sent to. Optionally, you can set an explicit display name for your run, add tags
        /// to your run, and set a default entity (team, username, etc) to be associated with your run.
        public var wandb: Wandb

        public enum `Type`: String, Codable, CaseIterable {
            case wandb
        }

        /// The settings for your integration with Weights and Biases. This payload specifies the project that
        /// metrics will be sent to. Optionally, you can set an explicit display name for your run, add tags
        /// to your run, and set a default entity (team, username, etc) to be associated with your run.
        public struct Wandb: Codable {
            /// The name of the project that the new run will be created under.
            ///
            /// Example: "my-wandb-project"
            public var project: String
            /// A display name to set for the run. If not set, we will use the Job ID as the name.
            public var name: String?
            /// The entity to use for the run. This allows you to set the team or username of the WandB user that you would
            /// like associated with the run. If not set, the default entity for the registered WandB API key is used.
            public var entity: String?
            /// A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some
            /// default tags are generated by OpenAI: "openai/finetune", "openai/{base-model}", "openai/{ftjob-abcdef}".
            public var tags: [String]?

            public init(project: String, name: String? = nil, entity: String? = nil, tags: [String]? = nil) {
                self.project = project
                self.name = name
                self.entity = entity
                self.tags = tags
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.project = try values.decode(String.self, forKey: "project")
                self.name = try values.decodeIfPresent(String.self, forKey: "name")
                self.entity = try values.decodeIfPresent(String.self, forKey: "entity")
                self.tags = try values.decodeIfPresent([String].self, forKey: "tags")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(project, forKey: "project")
                try values.encodeIfPresent(name, forKey: "name")
                try values.encodeIfPresent(entity, forKey: "entity")
                try values.encodeIfPresent(tags, forKey: "tags")
            }
        }

        public init(type: `Type`, wandb: Wandb) {
            self.type = type
            self.wandb = wandb
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.type = try values.decode(`Type`.self, forKey: "type")
            self.wandb = try values.decode(Wandb.self, forKey: "wandb")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(type, forKey: "type")
            try values.encode(wandb, forKey: "wandb")
        }
    }

    public init(model: Model, trainingFile: String, hyperparameters: Hyperparameters? = nil, suffix: String? = nil, validationFile: String? = nil, integrations: [Integration]? = nil, seed: Int? = nil, method: FineTuneMethod? = nil) {
        self.model = model
        self.trainingFile = trainingFile
        self.hyperparameters = hyperparameters
        self.suffix = suffix
        self.validationFile = validationFile
        self.integrations = integrations
        self.seed = seed
        self.method = method
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.model = try values.decode(Model.self, forKey: "model")
        self.trainingFile = try values.decode(String.self, forKey: "training_file")
        self.hyperparameters = try values.decodeIfPresent(Hyperparameters.self, forKey: "hyperparameters")
        self.suffix = try values.decodeIfPresent(String.self, forKey: "suffix")
        self.validationFile = try values.decodeIfPresent(String.self, forKey: "validation_file")
        self.integrations = try values.decodeIfPresent([Integration].self, forKey: "integrations")
        self.seed = try values.decodeIfPresent(Int.self, forKey: "seed")
        self.method = try values.decodeIfPresent(FineTuneMethod.self, forKey: "method")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(model, forKey: "model")
        try values.encode(trainingFile, forKey: "training_file")
        try values.encodeIfPresent(hyperparameters, forKey: "hyperparameters")
        try values.encodeIfPresent(suffix, forKey: "suffix")
        try values.encodeIfPresent(validationFile, forKey: "validation_file")
        try values.encodeIfPresent(integrations, forKey: "integrations")
        try values.encodeIfPresent(seed, forKey: "seed")
        try values.encodeIfPresent(method, forKey: "method")
    }
}
