// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Usage statistics for the completion request.
public struct CompletionUsage: Codable {
    /// Number of tokens in the generated completion.
    public var completionTokens: Int
    /// Number of tokens in the prompt.
    public var promptTokens: Int
    /// Total number of tokens used in the request (prompt + completion).
    public var totalTokens: Int
    /// Breakdown of tokens used in a completion.
    public var completionTokensDetails: CompletionTokensDetails?
    /// Breakdown of tokens used in the prompt.
    public var promptTokensDetails: PromptTokensDetails?

    /// Breakdown of tokens used in a completion.
    public struct CompletionTokensDetails: Codable {
        /// When using Predicted Outputs, the number of tokens in the
        /// prediction that appeared in the completion.
        public var acceptedPredictionTokens: Int?
        /// Audio input tokens generated by the model.
        public var audioTokens: Int?
        /// Tokens generated by the model for reasoning.
        public var reasoningTokens: Int?
        /// When using Predicted Outputs, the number of tokens in the
        /// prediction that did not appear in the completion. However, like
        /// reasoning tokens, these tokens are still counted in the total
        /// completion tokens for purposes of billing, output, and context window
        /// limits.
        public var rejectedPredictionTokens: Int?

        public init(acceptedPredictionTokens: Int? = nil, audioTokens: Int? = nil, reasoningTokens: Int? = nil, rejectedPredictionTokens: Int? = nil) {
            self.acceptedPredictionTokens = acceptedPredictionTokens
            self.audioTokens = audioTokens
            self.reasoningTokens = reasoningTokens
            self.rejectedPredictionTokens = rejectedPredictionTokens
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.acceptedPredictionTokens = try values.decodeIfPresent(Int.self, forKey: "accepted_prediction_tokens")
            self.audioTokens = try values.decodeIfPresent(Int.self, forKey: "audio_tokens")
            self.reasoningTokens = try values.decodeIfPresent(Int.self, forKey: "reasoning_tokens")
            self.rejectedPredictionTokens = try values.decodeIfPresent(Int.self, forKey: "rejected_prediction_tokens")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(acceptedPredictionTokens, forKey: "accepted_prediction_tokens")
            try values.encodeIfPresent(audioTokens, forKey: "audio_tokens")
            try values.encodeIfPresent(reasoningTokens, forKey: "reasoning_tokens")
            try values.encodeIfPresent(rejectedPredictionTokens, forKey: "rejected_prediction_tokens")
        }
    }

    /// Breakdown of tokens used in the prompt.
    public struct PromptTokensDetails: Codable {
        /// Audio input tokens present in the prompt.
        public var audioTokens: Int?
        /// Cached tokens present in the prompt.
        public var cachedTokens: Int?

        public init(audioTokens: Int? = nil, cachedTokens: Int? = nil) {
            self.audioTokens = audioTokens
            self.cachedTokens = cachedTokens
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.audioTokens = try values.decodeIfPresent(Int.self, forKey: "audio_tokens")
            self.cachedTokens = try values.decodeIfPresent(Int.self, forKey: "cached_tokens")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(audioTokens, forKey: "audio_tokens")
            try values.encodeIfPresent(cachedTokens, forKey: "cached_tokens")
        }
    }

    public init(completionTokens: Int, promptTokens: Int, totalTokens: Int, completionTokensDetails: CompletionTokensDetails? = nil, promptTokensDetails: PromptTokensDetails? = nil) {
        self.completionTokens = completionTokens
        self.promptTokens = promptTokens
        self.totalTokens = totalTokens
        self.completionTokensDetails = completionTokensDetails
        self.promptTokensDetails = promptTokensDetails
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.completionTokens = try values.decode(Int.self, forKey: "completion_tokens")
        self.promptTokens = try values.decode(Int.self, forKey: "prompt_tokens")
        self.totalTokens = try values.decode(Int.self, forKey: "total_tokens")
        self.completionTokensDetails = try values.decodeIfPresent(CompletionTokensDetails.self, forKey: "completion_tokens_details")
        self.promptTokensDetails = try values.decodeIfPresent(PromptTokensDetails.self, forKey: "prompt_tokens_details")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(completionTokens, forKey: "completion_tokens")
        try values.encode(promptTokens, forKey: "prompt_tokens")
        try values.encode(totalTokens, forKey: "total_tokens")
        try values.encodeIfPresent(completionTokensDetails, forKey: "completion_tokens_details")
        try values.encodeIfPresent(promptTokensDetails, forKey: "prompt_tokens_details")
    }
}
