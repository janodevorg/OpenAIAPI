// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// A chat completion message generated by the model.
public struct ChatCompletionResponseMessage: Codable {
    /// The contents of the message.
    public var content: String?
    /// The refusal message generated by the model.
    public var refusal: String?
    /// The tool calls generated by the model, such as function calls.
    public var toolCalls: [ChatCompletionMessageToolCall]?
    /// The role of the author of this message.
    public var role: Role
    /// Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
    ///
    /// - warning: Deprecated.
    public var functionCall: FunctionCall?
    /// If the audio output modality is requested, this object contains data
    /// about the audio response from the model. [Learn more](/docs/guides/audio).
    public var audio: Audio?

    /// The role of the author of this message.
    public enum Role: String, Codable, CaseIterable {
        case assistant
    }

    /// Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
    @available(*, deprecated, message: "Deprecated")
    public struct FunctionCall: Codable {
        /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
        public var arguments: String
        /// The name of the function to call.
        public var name: String

        public init(arguments: String, name: String) {
            self.arguments = arguments
            self.name = name
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.arguments = try values.decode(String.self, forKey: "arguments")
            self.name = try values.decode(String.self, forKey: "name")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(arguments, forKey: "arguments")
            try values.encode(name, forKey: "name")
        }
    }

    /// If the audio output modality is requested, this object contains data
    /// about the audio response from the model. [Learn more](/docs/guides/audio).
    public struct Audio: Codable {
        /// Unique identifier for this audio response.
        public var id: String
        /// The Unix timestamp (in seconds) for when this audio response will
        /// no longer be accessible on the server for use in multi-turn
        /// conversations.
        public var expiresAt: Int
        /// Base64 encoded audio bytes generated by the model, in the format
        /// specified in the request.
        public var data: String
        /// Transcript of the audio generated by the model.
        public var transcript: String

        public init(id: String, expiresAt: Int, data: String, transcript: String) {
            self.id = id
            self.expiresAt = expiresAt
            self.data = data
            self.transcript = transcript
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(String.self, forKey: "id")
            self.expiresAt = try values.decode(Int.self, forKey: "expires_at")
            self.data = try values.decode(String.self, forKey: "data")
            self.transcript = try values.decode(String.self, forKey: "transcript")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encode(expiresAt, forKey: "expires_at")
            try values.encode(data, forKey: "data")
            try values.encode(transcript, forKey: "transcript")
        }
    }

    public init(content: String? = nil, refusal: String? = nil, toolCalls: [ChatCompletionMessageToolCall]? = nil, role: Role, functionCall: FunctionCall? = nil, audio: Audio? = nil) {
        self.content = content
        self.refusal = refusal
        self.toolCalls = toolCalls
        self.role = role
        self.functionCall = functionCall
        self.audio = audio
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.content = try values.decodeIfPresent(String.self, forKey: "content")
        self.refusal = try values.decodeIfPresent(String.self, forKey: "refusal")
        self.toolCalls = try values.decodeIfPresent([ChatCompletionMessageToolCall].self, forKey: "tool_calls")
        self.role = try values.decode(Role.self, forKey: "role")
        self.functionCall = try values.decodeIfPresent(FunctionCall.self, forKey: "function_call")
        self.audio = try values.decodeIfPresent(Audio.self, forKey: "audio")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(content, forKey: "content")
        try values.encodeIfPresent(refusal, forKey: "refusal")
        try values.encodeIfPresent(toolCalls, forKey: "tool_calls")
        try values.encode(role, forKey: "role")
        try values.encodeIfPresent(functionCall, forKey: "function_call")
        try values.encodeIfPresent(audio, forKey: "audio")
    }
}
