// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Vector store files
///
/// A list of files attached to a vector store.
public struct VectorStoreFileObject: Codable {
    /// The identifier, which can be referenced in API endpoints.
    public var id: String
    /// The object type, which is always `vector_store.file`.
    public var object: Object
    /// The total vector store usage in bytes. Note that this may be different from the original file size.
    public var usageBytes: Int
    /// The Unix timestamp (in seconds) for when the vector store file was created.
    public var createdAt: Int
    /// The ID of the [vector store](/docs/api-reference/vector-stores/object) that the [File](/docs/api-reference/files) is attached to.
    public var vectorStoreID: String
    /// The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use.
    public var status: Status
    /// The last error associated with this vector store file. Will be `null` if there are no errors.
    public var lastError: LastError?
    /// The strategy used to chunk the file.
    public var chunkingStrategy: ChunkingStrategy?

    /// The object type, which is always `vector_store.file`.
    public enum Object: String, Codable, CaseIterable {
        case vectorStoreFile = "vector_store.file"
    }

    /// The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use.
    public enum Status: String, Codable, CaseIterable {
        case inProgress = "in_progress"
        case completed
        case cancelled
        case failed
    }

    /// The last error associated with this vector store file. Will be `null` if there are no errors.
    public struct LastError: Codable {
        /// One of `server_error` or `rate_limit_exceeded`.
        public var code: Code
        /// A human-readable description of the error.
        public var message: String

        /// One of `server_error` or `rate_limit_exceeded`.
        public enum Code: String, Codable, CaseIterable {
            case serverError = "server_error"
            case unsupportedFile = "unsupported_file"
            case invalidFile = "invalid_file"
        }

        public init(code: Code, message: String) {
            self.code = code
            self.message = message
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.code = try values.decode(Code.self, forKey: "code")
            self.message = try values.decode(String.self, forKey: "message")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(code, forKey: "code")
            try values.encode(message, forKey: "message")
        }
    }

    /// The strategy used to chunk the file.
    public enum ChunkingStrategy: Codable {
        case staticChunkingStrategyResponseParam(StaticChunkingStrategyResponseParam)
        case otherChunkingStrategyResponseParam(OtherChunkingStrategyResponseParam)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(StaticChunkingStrategyResponseParam.self) {
                self = .staticChunkingStrategyResponseParam(value)
            } else if let value = try? container.decode(OtherChunkingStrategyResponseParam.self) {
                self = .otherChunkingStrategyResponseParam(value)
            } else {
                throw DecodingError.dataCorruptedError(
                    in: container,
                    debugDescription: "Data could not be decoded as any of the expected types (StaticChunkingStrategyResponseParam, OtherChunkingStrategyResponseParam)."
                )
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .staticChunkingStrategyResponseParam(let value): try container.encode(value)
            case .otherChunkingStrategyResponseParam(let value): try container.encode(value)
            }
        }
    }

    public init(id: String, object: Object, usageBytes: Int, createdAt: Int, vectorStoreID: String, status: Status, lastError: LastError? = nil, chunkingStrategy: ChunkingStrategy? = nil) {
        self.id = id
        self.object = object
        self.usageBytes = usageBytes
        self.createdAt = createdAt
        self.vectorStoreID = vectorStoreID
        self.status = status
        self.lastError = lastError
        self.chunkingStrategy = chunkingStrategy
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.object = try values.decode(Object.self, forKey: "object")
        self.usageBytes = try values.decode(Int.self, forKey: "usage_bytes")
        self.createdAt = try values.decode(Int.self, forKey: "created_at")
        self.vectorStoreID = try values.decode(String.self, forKey: "vector_store_id")
        self.status = try values.decode(Status.self, forKey: "status")
        self.lastError = try values.decodeIfPresent(LastError.self, forKey: "last_error")
        self.chunkingStrategy = try values.decodeIfPresent(ChunkingStrategy.self, forKey: "chunking_strategy")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(object, forKey: "object")
        try values.encode(usageBytes, forKey: "usage_bytes")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(vectorStoreID, forKey: "vector_store_id")
        try values.encode(status, forKey: "status")
        try values.encodeIfPresent(lastError, forKey: "last_error")
        try values.encodeIfPresent(chunkingStrategy, forKey: "chunking_strategy")
    }
}
