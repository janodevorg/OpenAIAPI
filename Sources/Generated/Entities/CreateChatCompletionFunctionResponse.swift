// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Represents a chat completion response returned by model, based on the provided input.
public struct CreateChatCompletionFunctionResponse: Codable {
    /// A unique identifier for the chat completion.
    public var id: String
    /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
    public var choices: [Choice]
    /// The Unix timestamp (in seconds) of when the chat completion was created.
    public var created: Int
    /// The model used for the chat completion.
    public var model: String
    /// This fingerprint represents the backend configuration that the model runs with.
    /// 
    /// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
    public var systemFingerprint: String?
    /// The object type, which is always `chat.completion`.
    public var object: Object
    /// Usage statistics for the completion request.
    public var usage: CompletionUsage?

    public struct Choice: Codable {
        /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, or `function_call` if the model called a function.
        public var finishReason: FinishReason
        /// The index of the choice in the list of choices.
        public var index: Int
        /// A chat completion message generated by the model.
        public var message: ChatCompletionResponseMessage

        /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, or `function_call` if the model called a function.
        public enum FinishReason: String, Codable, CaseIterable {
            case stop
            case length
            case functionCall = "function_call"
            case contentFilter = "content_filter"
        }

        public init(finishReason: FinishReason, index: Int, message: ChatCompletionResponseMessage) {
            self.finishReason = finishReason
            self.index = index
            self.message = message
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.finishReason = try values.decode(FinishReason.self, forKey: "finish_reason")
            self.index = try values.decode(Int.self, forKey: "index")
            self.message = try values.decode(ChatCompletionResponseMessage.self, forKey: "message")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(finishReason, forKey: "finish_reason")
            try values.encode(index, forKey: "index")
            try values.encode(message, forKey: "message")
        }
    }

    /// The object type, which is always `chat.completion`.
    public enum Object: String, Codable, CaseIterable {
        case chatCompletion = "chat.completion"
    }

    public init(id: String, choices: [Choice], created: Int, model: String, systemFingerprint: String? = nil, object: Object, usage: CompletionUsage? = nil) {
        self.id = id
        self.choices = choices
        self.created = created
        self.model = model
        self.systemFingerprint = systemFingerprint
        self.object = object
        self.usage = usage
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.choices = try values.decode([Choice].self, forKey: "choices")
        self.created = try values.decode(Int.self, forKey: "created")
        self.model = try values.decode(String.self, forKey: "model")
        self.systemFingerprint = try values.decodeIfPresent(String.self, forKey: "system_fingerprint")
        self.object = try values.decode(Object.self, forKey: "object")
        self.usage = try values.decodeIfPresent(CompletionUsage.self, forKey: "usage")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(choices, forKey: "choices")
        try values.encode(created, forKey: "created")
        try values.encode(model, forKey: "model")
        try values.encodeIfPresent(systemFingerprint, forKey: "system_fingerprint")
        try values.encode(object, forKey: "object")
        try values.encodeIfPresent(usage, forKey: "usage")
    }
}
