// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct CreateMessageRequest: Codable {
    /// The role of the entity that is creating the message. Allowed values include:
    /// - `user`: Indicates the message is sent by an actual user and should be used in most cases to represent user-generated messages.
    /// - `assistant`: Indicates the message is generated by the assistant. Use this value to insert messages from the assistant into the conversation.
    public var role: Role
    public var content: Content
    /// A list of files attached to the message, and the tools they should be added to.
    public var attachments: [Attachmants]?
    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
    public var metadata: [String: AnyJSON]?

    /// The role of the entity that is creating the message. Allowed values include:
    /// - `user`: Indicates the message is sent by an actual user and should be used in most cases to represent user-generated messages.
    /// - `assistant`: Indicates the message is generated by the assistant. Use this value to insert messages from the assistant into the conversation.
    public enum Role: String, Codable, CaseIterable {
        case user
        case assistant
    }

    public enum Content: Codable {
        case string(String)
        case placeholderItems([PlaceholderItem])

        public enum PlaceholderItem: Codable {
            case messageContentImageFileObject(MessageContentImageFileObject)
            case messageContentImageURLObject(MessageContentImageURLObject)
            case messageRequestContentTextObject(MessageRequestContentTextObject)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(MessageContentImageFileObject.self) {
                    self = .messageContentImageFileObject(value)
                } else if let value = try? container.decode(MessageContentImageURLObject.self) {
                    self = .messageContentImageURLObject(value)
                } else if let value = try? container.decode(MessageRequestContentTextObject.self) {
                    self = .messageRequestContentTextObject(value)
                } else {
                    throw DecodingError.dataCorruptedError(
                        in: container,
                        debugDescription: "Data could not be decoded as any of the expected types (MessageContentImageFileObject, MessageContentImageURLObject, MessageRequestContentTextObject)."
                    )
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .messageContentImageFileObject(let value): try container.encode(value)
                case .messageContentImageURLObject(let value): try container.encode(value)
                case .messageRequestContentTextObject(let value): try container.encode(value)
                }
            }
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(String.self) {
                self = .string(value)
            } else if let value = try? container.decode([PlaceholderItem].self) {
                self = .placeholderItems(value)
            } else {
                throw DecodingError.dataCorruptedError(
                    in: container,
                    debugDescription: "Data could not be decoded as any of the expected types (String, [PlaceholderItem])."
                )
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .string(let value): try container.encode(value)
            case .placeholderItems(let value): try container.encode(value)
            }
        }
    }

    public struct Attachmants: Codable {
        /// The ID of the file to attach to the message.
        public var fileID: String?
        /// The tools to add this file to.
        public var tools: [Tool]?

        public enum Tool: Codable {
            case assistantToolsCode(AssistantToolsCode)
            case assistantToolsFileSearchTypeOnly(AssistantToolsFileSearchTypeOnly)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(AssistantToolsCode.self) {
                    self = .assistantToolsCode(value)
                } else if let value = try? container.decode(AssistantToolsFileSearchTypeOnly.self) {
                    self = .assistantToolsFileSearchTypeOnly(value)
                } else {
                    throw DecodingError.dataCorruptedError(
                        in: container,
                        debugDescription: "Data could not be decoded as any of the expected types (AssistantToolsCode, AssistantToolsFileSearchTypeOnly)."
                    )
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .assistantToolsCode(let value): try container.encode(value)
                case .assistantToolsFileSearchTypeOnly(let value): try container.encode(value)
                }
            }
        }

        public init(fileID: String? = nil, tools: [Tool]? = nil) {
            self.fileID = fileID
            self.tools = tools
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.fileID = try values.decodeIfPresent(String.self, forKey: "file_id")
            self.tools = try values.decodeIfPresent([Tool].self, forKey: "tools")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(fileID, forKey: "file_id")
            try values.encodeIfPresent(tools, forKey: "tools")
        }
    }

    public init(role: Role, content: Content, attachments: [Attachmants]? = nil, metadata: [String: AnyJSON]? = nil) {
        self.role = role
        self.content = content
        self.attachments = attachments
        self.metadata = metadata
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.role = try values.decode(Role.self, forKey: "role")
        self.content = try values.decode(Content.self, forKey: "content")
        self.attachments = try values.decodeIfPresent([Attachmants].self, forKey: "attachments")
        self.metadata = try values.decodeIfPresent([String: AnyJSON].self, forKey: "metadata")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(role, forKey: "role")
        try values.encode(content, forKey: "content")
        try values.encodeIfPresent(attachments, forKey: "attachments")
        try values.encodeIfPresent(metadata, forKey: "metadata")
    }
}
