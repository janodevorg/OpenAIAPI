// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Returned when input audio transcription is configured, and a transcription 
/// request for a user message failed. These events are separate from other 
/// `error` events so that the client can identify the related Item.
public struct RealtimeServerEventConversationItemInputAudioTranscriptionFailed: Codable {
    /// The unique ID of the server event.
    public var eventID: String
    /// The event type, must be
    /// `conversation.item.input_audio_transcription.failed`.
    public var type: `Type`
    /// The ID of the user message item.
    public var itemID: String
    /// The index of the content part containing the audio.
    public var contentIndex: Int
    /// Details of the transcription error.
    public var error: Error

    /// The event type, must be
    /// `conversation.item.input_audio_transcription.failed`.
    public enum `Type`: String, Codable, CaseIterable {
        case conversationItemInputAudioTranscriptionFailed = "conversation.item.input_audio_transcription.failed"
    }

    /// Details of the transcription error.
    public struct Error: Codable {
        /// The type of error.
        public var type: String?
        /// Error code, if any.
        public var code: String?
        /// A human-readable error message.
        public var message: String?
        /// Parameter related to the error, if any.
        public var param: String?

        public init(type: String? = nil, code: String? = nil, message: String? = nil, param: String? = nil) {
            self.type = type
            self.code = code
            self.message = message
            self.param = param
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.type = try values.decodeIfPresent(String.self, forKey: "type")
            self.code = try values.decodeIfPresent(String.self, forKey: "code")
            self.message = try values.decodeIfPresent(String.self, forKey: "message")
            self.param = try values.decodeIfPresent(String.self, forKey: "param")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(type, forKey: "type")
            try values.encodeIfPresent(code, forKey: "code")
            try values.encodeIfPresent(message, forKey: "message")
            try values.encodeIfPresent(param, forKey: "param")
        }
    }

    public init(eventID: String, type: `Type`, itemID: String, contentIndex: Int, error: Error) {
        self.eventID = eventID
        self.type = type
        self.itemID = itemID
        self.contentIndex = contentIndex
        self.error = error
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.eventID = try values.decode(String.self, forKey: "event_id")
        self.type = try values.decode(`Type`.self, forKey: "type")
        self.itemID = try values.decode(String.self, forKey: "item_id")
        self.contentIndex = try values.decode(Int.self, forKey: "content_index")
        self.error = try values.decode(Error.self, forKey: "error")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(eventID, forKey: "event_id")
        try values.encode(type, forKey: "type")
        try values.encode(itemID, forKey: "item_id")
        try values.encode(contentIndex, forKey: "content_index")
        try values.encode(error, forKey: "error")
    }
}
