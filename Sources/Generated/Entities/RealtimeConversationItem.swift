// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// The item to add to the conversation.
public struct RealtimeConversationItem: Codable {
    /// The unique ID of the item, this can be generated by the client to help 
    /// manage server-side context, but is not required because the server will 
    /// generate one if not provided.
    public var id: String?
    /// The type of the item (`message`, `function_call`, `function_call_output`).
    public var type: `Type`?
    /// Identifier for the API object being returned - always `realtime.item`.
    public var object: Object?
    /// The status of the item (`completed`, `incomplete`). These have no effect 
    /// on the conversation, but are accepted for consistency with the 
    /// `conversation.item.created` event.
    public var status: Status?
    /// The role of the message sender (`user`, `assistant`, `system`), only 
    /// applicable for `message` items.
    public var role: Role?
    /// The content of the message, applicable for `message` items. 
    /// - Message items of role `system` support only `input_text` content
    /// - Message items of role `user` support `input_text` and `input_audio` 
    ///   content
    /// - Message items of role `assistant` support `text` content.
    public var content: [ContentItem]?
    /// The ID of the function call (for `function_call` and 
    /// `function_call_output` items). If passed on a `function_call_output` 
    /// item, the server will check that a `function_call` item with the same 
    /// ID exists in the conversation history.
    public var callID: String?
    /// The name of the function being called (for `function_call` items).
    public var name: String?
    /// The arguments of the function call (for `function_call` items).
    public var arguments: String?
    /// The output of the function call (for `function_call_output` items).
    public var output: String?

    /// The type of the item (`message`, `function_call`, `function_call_output`).
    public enum `Type`: String, Codable, CaseIterable {
        case message
        case functionCall = "function_call"
        case functionCallOutput = "function_call_output"
    }

    /// Identifier for the API object being returned - always `realtime.item`.
    public enum Object: String, Codable, CaseIterable {
        case realtimeItem = "realtime.item"
    }

    /// The status of the item (`completed`, `incomplete`). These have no effect 
    /// on the conversation, but are accepted for consistency with the 
    /// `conversation.item.created` event.
    public enum Status: String, Codable, CaseIterable {
        case completed
        case incomplete
    }

    /// The role of the message sender (`user`, `assistant`, `system`), only 
    /// applicable for `message` items.
    public enum Role: String, Codable, CaseIterable {
        case user
        case assistant
        case system
    }

    public struct ContentItem: Codable {
        /// The content type (`input_text`, `input_audio`, `item_reference`, `text`).
        public var type: `Type`?
        /// The text content, used for `input_text` and `text` content types.
        public var text: String?
        /// ID of a previous conversation item to reference (for `item_reference`
        /// content types in `response.create` events). These can reference both
        /// client and server created items.
        public var id: String?
        /// Base64-encoded audio bytes, used for `input_audio` content type.
        public var audio: String?
        /// The transcript of the audio, used for `input_audio` content type.
        public var transcript: String?

        /// The content type (`input_text`, `input_audio`, `item_reference`, `text`).
        public enum `Type`: String, Codable, CaseIterable {
            case inputAudio = "input_audio"
            case inputText = "input_text"
            case itemReference = "item_reference"
            case text
        }

        public init(type: `Type`? = nil, text: String? = nil, id: String? = nil, audio: String? = nil, transcript: String? = nil) {
            self.type = type
            self.text = text
            self.id = id
            self.audio = audio
            self.transcript = transcript
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.type = try values.decodeIfPresent(`Type`.self, forKey: "type")
            self.text = try values.decodeIfPresent(String.self, forKey: "text")
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.audio = try values.decodeIfPresent(String.self, forKey: "audio")
            self.transcript = try values.decodeIfPresent(String.self, forKey: "transcript")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(type, forKey: "type")
            try values.encodeIfPresent(text, forKey: "text")
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(audio, forKey: "audio")
            try values.encodeIfPresent(transcript, forKey: "transcript")
        }
    }

    public init(id: String? = nil, type: `Type`? = nil, object: Object? = nil, status: Status? = nil, role: Role? = nil, content: [ContentItem]? = nil, callID: String? = nil, name: String? = nil, arguments: String? = nil, output: String? = nil) {
        self.id = id
        self.type = type
        self.object = object
        self.status = status
        self.role = role
        self.content = content
        self.callID = callID
        self.name = name
        self.arguments = arguments
        self.output = output
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decodeIfPresent(String.self, forKey: "id")
        self.type = try values.decodeIfPresent(`Type`.self, forKey: "type")
        self.object = try values.decodeIfPresent(Object.self, forKey: "object")
        self.status = try values.decodeIfPresent(Status.self, forKey: "status")
        self.role = try values.decodeIfPresent(Role.self, forKey: "role")
        self.content = try values.decodeIfPresent([ContentItem].self, forKey: "content")
        self.callID = try values.decodeIfPresent(String.self, forKey: "call_id")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.arguments = try values.decodeIfPresent(String.self, forKey: "arguments")
        self.output = try values.decodeIfPresent(String.self, forKey: "output")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encodeIfPresent(object, forKey: "object")
        try values.encodeIfPresent(status, forKey: "status")
        try values.encodeIfPresent(role, forKey: "role")
        try values.encodeIfPresent(content, forKey: "content")
        try values.encodeIfPresent(callID, forKey: "call_id")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(arguments, forKey: "arguments")
        try values.encodeIfPresent(output, forKey: "output")
    }
}
