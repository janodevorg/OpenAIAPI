// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// The `fine_tuning.job` object represents a fine-tuning job that has been created through the API.
public struct FineTuningJob: Codable {
    /// The object identifier, which can be referenced in the API endpoints.
    public var id: String
    /// The Unix timestamp (in seconds) for when the fine-tuning job was created.
    public var createdAt: Int
    /// For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
    public var error: Error?
    /// The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
    public var fineTunedModel: String?
    /// The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
    public var finishedAt: Int?
    /// The hyperparameters used for the fine-tuning job. This value will only be returned when running `supervised` jobs.
    public var hyperparameters: Hyperparameters
    /// The base model that is being fine-tuned.
    public var model: String
    /// The object type, which is always "fine_tuning.job".
    public var object: Object
    /// The organization that owns the fine-tuning job.
    public var organizationID: String
    /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](/docs/api-reference/files/retrieve-contents).
    public var resultFiles: [String]
    /// The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
    public var status: Status
    /// The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
    public var trainedTokens: Int?
    /// The file ID used for training. You can retrieve the training data with the [Files API](/docs/api-reference/files/retrieve-contents).
    public var trainingFile: String
    /// The file ID used for validation. You can retrieve the validation results with the [Files API](/docs/api-reference/files/retrieve-contents).
    public var validationFile: String?
    /// A list of integrations to enable for this fine-tuning job.
    public var integrations: [FineTuningIntegration]?
    /// The seed used for the fine-tuning job.
    public var seed: Int
    /// The Unix timestamp (in seconds) for when the fine-tuning job is estimated to finish. The value will be null if the fine-tuning job is not running.
    public var estimatedFinish: Int?
    /// The method used for fine-tuning.
    public var method: FineTuneMethod?

    /// For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
    public struct Error: Codable {
        /// A machine-readable error code.
        public var code: String
        /// A human-readable error message.
        public var message: String
        /// The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
        public var param: String?

        public init(code: String, message: String, param: String? = nil) {
            self.code = code
            self.message = message
            self.param = param
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.code = try values.decode(String.self, forKey: "code")
            self.message = try values.decode(String.self, forKey: "message")
            self.param = try values.decodeIfPresent(String.self, forKey: "param")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(code, forKey: "code")
            try values.encode(message, forKey: "message")
            try values.encodeIfPresent(param, forKey: "param")
        }
    }

    /// The hyperparameters used for the fine-tuning job. This value will only be returned when running `supervised` jobs.
    public struct Hyperparameters: Codable {
        /// Number of examples in each batch. A larger batch size means that model parameters
        /// are updated less frequently, but with lower variance.
        public var batchSize: BatchSize?
        /// Scaling factor for the learning rate. A smaller learning rate may be useful to avoid
        /// overfitting.
        public var learningRateMultiplier: LearningRateMultiplier?
        /// The number of epochs to train the model for. An epoch refers to one full cycle
        /// through the training dataset.
        public var nEpochs: NEpochs?

        /// Number of examples in each batch. A larger batch size means that model parameters
        /// are updated less frequently, but with lower variance.
        public enum BatchSize: Codable {
            case object(Object)
            case int(Int)

            public enum Object: String, Codable, CaseIterable {
                case auto
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(Object.self) {
                    self = .object(value)
                } else if let value = try? container.decode(Int.self) {
                    self = .int(value)
                } else {
                    throw DecodingError.dataCorruptedError(
                        in: container,
                        debugDescription: "Data could not be decoded as any of the expected types (Object, Int)."
                    )
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .object(let value): try container.encode(value)
                case .int(let value): try container.encode(value)
                }
            }
        }

        /// Scaling factor for the learning rate. A smaller learning rate may be useful to avoid
        /// overfitting.
        public enum LearningRateMultiplier: Codable {
            case object(Object)
            case double(Double)

            public enum Object: String, Codable, CaseIterable {
                case auto
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(Object.self) {
                    self = .object(value)
                } else if let value = try? container.decode(Double.self) {
                    self = .double(value)
                } else {
                    throw DecodingError.dataCorruptedError(
                        in: container,
                        debugDescription: "Data could not be decoded as any of the expected types (Object, Double)."
                    )
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .object(let value): try container.encode(value)
                case .double(let value): try container.encode(value)
                }
            }
        }

        /// The number of epochs to train the model for. An epoch refers to one full cycle
        /// through the training dataset.
        public enum NEpochs: Codable {
            case object(Object)
            case int(Int)

            public enum Object: String, Codable, CaseIterable {
                case auto
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(Object.self) {
                    self = .object(value)
                } else if let value = try? container.decode(Int.self) {
                    self = .int(value)
                } else {
                    throw DecodingError.dataCorruptedError(
                        in: container,
                        debugDescription: "Data could not be decoded as any of the expected types (Object, Int)."
                    )
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .object(let value): try container.encode(value)
                case .int(let value): try container.encode(value)
                }
            }
        }

        public init(batchSize: BatchSize? = nil, learningRateMultiplier: LearningRateMultiplier? = nil, nEpochs: NEpochs? = nil) {
            self.batchSize = batchSize
            self.learningRateMultiplier = learningRateMultiplier
            self.nEpochs = nEpochs
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.batchSize = try values.decodeIfPresent(BatchSize.self, forKey: "batch_size")
            self.learningRateMultiplier = try values.decodeIfPresent(LearningRateMultiplier.self, forKey: "learning_rate_multiplier")
            self.nEpochs = try values.decodeIfPresent(NEpochs.self, forKey: "n_epochs")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(batchSize, forKey: "batch_size")
            try values.encodeIfPresent(learningRateMultiplier, forKey: "learning_rate_multiplier")
            try values.encodeIfPresent(nEpochs, forKey: "n_epochs")
        }
    }

    /// The object type, which is always "fine_tuning.job".
    public enum Object: String, Codable, CaseIterable {
        case fineTuningJob = "fine_tuning.job"
    }

    /// The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
    public enum Status: String, Codable, CaseIterable {
        case validatingFiles = "validating_files"
        case queued
        case running
        case succeeded
        case failed
        case cancelled
    }

    public init(id: String, createdAt: Int, error: Error? = nil, fineTunedModel: String? = nil, finishedAt: Int? = nil, hyperparameters: Hyperparameters, model: String, object: Object, organizationID: String, resultFiles: [String], status: Status, trainedTokens: Int? = nil, trainingFile: String, validationFile: String? = nil, integrations: [FineTuningIntegration]? = nil, seed: Int, estimatedFinish: Int? = nil, method: FineTuneMethod? = nil) {
        self.id = id
        self.createdAt = createdAt
        self.error = error
        self.fineTunedModel = fineTunedModel
        self.finishedAt = finishedAt
        self.hyperparameters = hyperparameters
        self.model = model
        self.object = object
        self.organizationID = organizationID
        self.resultFiles = resultFiles
        self.status = status
        self.trainedTokens = trainedTokens
        self.trainingFile = trainingFile
        self.validationFile = validationFile
        self.integrations = integrations
        self.seed = seed
        self.estimatedFinish = estimatedFinish
        self.method = method
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(String.self, forKey: "id")
        self.createdAt = try values.decode(Int.self, forKey: "created_at")
        self.error = try values.decodeIfPresent(Error.self, forKey: "error")
        self.fineTunedModel = try values.decodeIfPresent(String.self, forKey: "fine_tuned_model")
        self.finishedAt = try values.decodeIfPresent(Int.self, forKey: "finished_at")
        self.hyperparameters = try values.decode(Hyperparameters.self, forKey: "hyperparameters")
        self.model = try values.decode(String.self, forKey: "model")
        self.object = try values.decode(Object.self, forKey: "object")
        self.organizationID = try values.decode(String.self, forKey: "organization_id")
        self.resultFiles = try values.decode([String].self, forKey: "result_files")
        self.status = try values.decode(Status.self, forKey: "status")
        self.trainedTokens = try values.decodeIfPresent(Int.self, forKey: "trained_tokens")
        self.trainingFile = try values.decode(String.self, forKey: "training_file")
        self.validationFile = try values.decodeIfPresent(String.self, forKey: "validation_file")
        self.integrations = try values.decodeIfPresent([FineTuningIntegration].self, forKey: "integrations")
        self.seed = try values.decode(Int.self, forKey: "seed")
        self.estimatedFinish = try values.decodeIfPresent(Int.self, forKey: "estimated_finish")
        self.method = try values.decodeIfPresent(FineTuneMethod.self, forKey: "method")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(createdAt, forKey: "created_at")
        try values.encodeIfPresent(error, forKey: "error")
        try values.encodeIfPresent(fineTunedModel, forKey: "fine_tuned_model")
        try values.encodeIfPresent(finishedAt, forKey: "finished_at")
        try values.encode(hyperparameters, forKey: "hyperparameters")
        try values.encode(model, forKey: "model")
        try values.encode(object, forKey: "object")
        try values.encode(organizationID, forKey: "organization_id")
        try values.encode(resultFiles, forKey: "result_files")
        try values.encode(status, forKey: "status")
        try values.encodeIfPresent(trainedTokens, forKey: "trained_tokens")
        try values.encode(trainingFile, forKey: "training_file")
        try values.encodeIfPresent(validationFile, forKey: "validation_file")
        try values.encodeIfPresent(integrations, forKey: "integrations")
        try values.encode(seed, forKey: "seed")
        try values.encodeIfPresent(estimatedFinish, forKey: "estimated_finish")
        try values.encodeIfPresent(method, forKey: "method")
    }
}
