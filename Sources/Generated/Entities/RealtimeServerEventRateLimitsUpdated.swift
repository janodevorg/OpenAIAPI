// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Emitted at the beginning of a Response to indicate the updated rate limits. 
/// When a Response is created some tokens will be "reserved" for the output 
/// tokens, the rate limits shown here reflect that reservation, which is then 
/// adjusted accordingly once the Response is completed.
public struct RealtimeServerEventRateLimitsUpdated: Codable {
    /// The unique ID of the server event.
    public var eventID: String
    /// The event type, must be `rate_limits.updated`.
    public var type: `Type`
    /// List of rate limit information.
    public var rateLimits: [RateLimit]

    /// The event type, must be `rate_limits.updated`.
    public enum `Type`: String, Codable, CaseIterable {
        case rateLimitsUpdated = "rate_limits.updated"
    }

    public struct RateLimit: Codable {
        /// The name of the rate limit (`requests`, `tokens`).
        public var name: Name?
        /// The maximum allowed value for the rate limit.
        public var limit: Int?
        /// The remaining value before the limit is reached.
        public var remaining: Int?
        /// Seconds until the rate limit resets.
        public var resetSeconds: Double?

        /// The name of the rate limit (`requests`, `tokens`).
        public enum Name: String, Codable, CaseIterable {
            case requests
            case tokens
        }

        public init(name: Name? = nil, limit: Int? = nil, remaining: Int? = nil, resetSeconds: Double? = nil) {
            self.name = name
            self.limit = limit
            self.remaining = remaining
            self.resetSeconds = resetSeconds
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.name = try values.decodeIfPresent(Name.self, forKey: "name")
            self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
            self.remaining = try values.decodeIfPresent(Int.self, forKey: "remaining")
            self.resetSeconds = try values.decodeIfPresent(Double.self, forKey: "reset_seconds")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(limit, forKey: "limit")
            try values.encodeIfPresent(remaining, forKey: "remaining")
            try values.encodeIfPresent(resetSeconds, forKey: "reset_seconds")
        }
    }

    public init(eventID: String, type: `Type`, rateLimits: [RateLimit]) {
        self.eventID = eventID
        self.type = type
        self.rateLimits = rateLimits
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.eventID = try values.decode(String.self, forKey: "event_id")
        self.type = try values.decode(`Type`.self, forKey: "type")
        self.rateLimits = try values.decode([RateLimit].self, forKey: "rate_limits")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(eventID, forKey: "event_id")
        try values.encode(type, forKey: "type")
        try values.encode(rateLimits, forKey: "rate_limits")
    }
}
