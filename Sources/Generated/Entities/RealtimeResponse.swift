// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// The response resource.
public struct RealtimeResponse: Codable {
    /// The unique ID of the response.
    public var id: String?
    /// The object type, must be `realtime.response`.
    public var object: Object?
    /// The final status of the response (`completed`, `cancelled`, `failed`, or 
    /// `incomplete`).
    public var status: Status?
    /// Additional details about the status.
    public var statusDetails: StatusDetails?
    /// The list of output items generated by the response.
    public var output: [RealtimeConversationItem]?
    /// Developer-provided string key-value pairs associated with this response.
    public var metadata: [String: AnyJSON]?
    /// Usage statistics for the Response, this will correspond to billing. A 
    /// Realtime API session will maintain a conversation context and append new 
    /// Items to the Conversation, thus output from previous turns (text and 
    /// audio tokens) will become the input for later turns.
    public var usage: Usage?

    /// The object type, must be `realtime.response`.
    public enum Object: String, Codable, CaseIterable {
        case realtimeResponse = "realtime.response"
    }

    /// The final status of the response (`completed`, `cancelled`, `failed`, or 
    /// `incomplete`).
    public enum Status: String, Codable, CaseIterable {
        case completed
        case cancelled
        case failed
        case incomplete
    }

    /// Additional details about the status.
    public struct StatusDetails: Codable {
        /// The type of error that caused the response to fail, corresponding 
        /// with the `status` field (`completed`, `cancelled`, `incomplete`, 
        /// `failed`).
        public var type: `Type`?
        /// The reason the Response did not complete. For a `cancelled` Response, 
        /// one of `turn_detected` (the server VAD detected a new start of speech) 
        /// or `client_cancelled` (the client sent a cancel event). For an 
        /// `incomplete` Response, one of `max_output_tokens` or `content_filter` 
        /// (the server-side safety filter activated and cut off the response).
        public var reason: Reason?
        /// A description of the error that caused the response to fail, 
        /// populated when the `status` is `failed`.
        public var error: Error?

        /// The type of error that caused the response to fail, corresponding 
        /// with the `status` field (`completed`, `cancelled`, `incomplete`, 
        /// `failed`).
        public enum `Type`: String, Codable, CaseIterable {
            case completed
            case cancelled
            case failed
            case incomplete
        }

        /// The reason the Response did not complete. For a `cancelled` Response, 
        /// one of `turn_detected` (the server VAD detected a new start of speech) 
        /// or `client_cancelled` (the client sent a cancel event). For an 
        /// `incomplete` Response, one of `max_output_tokens` or `content_filter` 
        /// (the server-side safety filter activated and cut off the response).
        public enum Reason: String, Codable, CaseIterable {
            case turnDetected = "turn_detected"
            case clientCancelled = "client_cancelled"
            case maxOutputTokens = "max_output_tokens"
            case contentFilter = "content_filter"
        }

        /// A description of the error that caused the response to fail, 
        /// populated when the `status` is `failed`.
        public struct Error: Codable {
            /// The type of error.
            public var type: String?
            /// Error code, if any.
            public var code: String?

            public init(type: String? = nil, code: String? = nil) {
                self.type = type
                self.code = code
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.type = try values.decodeIfPresent(String.self, forKey: "type")
                self.code = try values.decodeIfPresent(String.self, forKey: "code")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(type, forKey: "type")
                try values.encodeIfPresent(code, forKey: "code")
            }
        }

        public init(type: `Type`? = nil, reason: Reason? = nil, error: Error? = nil) {
            self.type = type
            self.reason = reason
            self.error = error
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.type = try values.decodeIfPresent(`Type`.self, forKey: "type")
            self.reason = try values.decodeIfPresent(Reason.self, forKey: "reason")
            self.error = try values.decodeIfPresent(Error.self, forKey: "error")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(type, forKey: "type")
            try values.encodeIfPresent(reason, forKey: "reason")
            try values.encodeIfPresent(error, forKey: "error")
        }
    }

    /// Usage statistics for the Response, this will correspond to billing. A 
    /// Realtime API session will maintain a conversation context and append new 
    /// Items to the Conversation, thus output from previous turns (text and 
    /// audio tokens) will become the input for later turns.
    public struct Usage: Codable {
        /// The total number of tokens in the Response including input and output 
        /// text and audio tokens.
        public var totalTokens: Int?
        /// The number of input tokens used in the Response, including text and 
        /// audio tokens.
        public var inputTokens: Int?
        /// The number of output tokens sent in the Response, including text and 
        /// audio tokens.
        public var outputTokens: Int?
        /// Details about the input tokens used in the Response.
        public var inputTokenDetails: InputTokenDetails?
        /// Details about the output tokens used in the Response.
        public var outputTokenDetails: OutputTokenDetails?

        /// Details about the input tokens used in the Response.
        public struct InputTokenDetails: Codable {
            /// The number of cached tokens used in the Response.
            public var cachedTokens: Int?
            /// The number of text tokens used in the Response.
            public var textTokens: Int?
            /// The number of audio tokens used in the Response.
            public var audioTokens: Int?

            public init(cachedTokens: Int? = nil, textTokens: Int? = nil, audioTokens: Int? = nil) {
                self.cachedTokens = cachedTokens
                self.textTokens = textTokens
                self.audioTokens = audioTokens
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.cachedTokens = try values.decodeIfPresent(Int.self, forKey: "cached_tokens")
                self.textTokens = try values.decodeIfPresent(Int.self, forKey: "text_tokens")
                self.audioTokens = try values.decodeIfPresent(Int.self, forKey: "audio_tokens")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(cachedTokens, forKey: "cached_tokens")
                try values.encodeIfPresent(textTokens, forKey: "text_tokens")
                try values.encodeIfPresent(audioTokens, forKey: "audio_tokens")
            }
        }

        /// Details about the output tokens used in the Response.
        public struct OutputTokenDetails: Codable {
            /// The number of text tokens used in the Response.
            public var textTokens: Int?
            /// The number of audio tokens used in the Response.
            public var audioTokens: Int?

            public init(textTokens: Int? = nil, audioTokens: Int? = nil) {
                self.textTokens = textTokens
                self.audioTokens = audioTokens
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.textTokens = try values.decodeIfPresent(Int.self, forKey: "text_tokens")
                self.audioTokens = try values.decodeIfPresent(Int.self, forKey: "audio_tokens")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(textTokens, forKey: "text_tokens")
                try values.encodeIfPresent(audioTokens, forKey: "audio_tokens")
            }
        }

        public init(totalTokens: Int? = nil, inputTokens: Int? = nil, outputTokens: Int? = nil, inputTokenDetails: InputTokenDetails? = nil, outputTokenDetails: OutputTokenDetails? = nil) {
            self.totalTokens = totalTokens
            self.inputTokens = inputTokens
            self.outputTokens = outputTokens
            self.inputTokenDetails = inputTokenDetails
            self.outputTokenDetails = outputTokenDetails
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.totalTokens = try values.decodeIfPresent(Int.self, forKey: "total_tokens")
            self.inputTokens = try values.decodeIfPresent(Int.self, forKey: "input_tokens")
            self.outputTokens = try values.decodeIfPresent(Int.self, forKey: "output_tokens")
            self.inputTokenDetails = try values.decodeIfPresent(InputTokenDetails.self, forKey: "input_token_details")
            self.outputTokenDetails = try values.decodeIfPresent(OutputTokenDetails.self, forKey: "output_token_details")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(totalTokens, forKey: "total_tokens")
            try values.encodeIfPresent(inputTokens, forKey: "input_tokens")
            try values.encodeIfPresent(outputTokens, forKey: "output_tokens")
            try values.encodeIfPresent(inputTokenDetails, forKey: "input_token_details")
            try values.encodeIfPresent(outputTokenDetails, forKey: "output_token_details")
        }
    }

    public init(id: String? = nil, object: Object? = nil, status: Status? = nil, statusDetails: StatusDetails? = nil, output: [RealtimeConversationItem]? = nil, metadata: [String: AnyJSON]? = nil, usage: Usage? = nil) {
        self.id = id
        self.object = object
        self.status = status
        self.statusDetails = statusDetails
        self.output = output
        self.metadata = metadata
        self.usage = usage
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decodeIfPresent(String.self, forKey: "id")
        self.object = try values.decodeIfPresent(Object.self, forKey: "object")
        self.status = try values.decodeIfPresent(Status.self, forKey: "status")
        self.statusDetails = try values.decodeIfPresent(StatusDetails.self, forKey: "status_details")
        self.output = try values.decodeIfPresent([RealtimeConversationItem].self, forKey: "output")
        self.metadata = try values.decodeIfPresent([String: AnyJSON].self, forKey: "metadata")
        self.usage = try values.decodeIfPresent(Usage.self, forKey: "usage")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(object, forKey: "object")
        try values.encodeIfPresent(status, forKey: "status")
        try values.encodeIfPresent(statusDetails, forKey: "status_details")
        try values.encodeIfPresent(output, forKey: "output")
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encodeIfPresent(usage, forKey: "usage")
    }
}
