// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Represents an event emitted when streaming a Run.
/// 
/// Each event in a server-sent events stream has an `event` and `data` property:
/// 
/// ```
/// event: thread.created
/// data: {"id": "thread_123", "object": "thread", ...}
/// ```
/// 
/// We emit events whenever a new object is created, transitions to a new state, or is being
/// streamed in parts (deltas). For example, we emit `thread.run.created` when a new run
/// is created, `thread.run.completed` when a run completes, and so on. When an Assistant chooses
/// to create a message during a run, we emit a `thread.message.created event`, a
/// `thread.message.in_progress` event, many `thread.message.delta` events, and finally a
/// `thread.message.completed` event.
/// 
/// We may add additional events over time, so we recommend handling unknown events gracefully
/// in your code. See the [Assistants API quickstart](/docs/assistants/overview) to learn how to
/// integrate the Assistants API with streaming.
public enum AssistantStreamEvent: Codable {
    case threadStreamEvent(ThreadStreamEvent)
    case runStreamEvent(RunStreamEvent)
    case runStepStreamEvent(RunStepStreamEvent)
    case messageStreamEvent(MessageStreamEvent)
    case errorEvent(ErrorEvent)
    case doneEvent(DoneEvent)

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(ThreadStreamEvent.self) {
            self = .threadStreamEvent(value)
        } else if let value = try? container.decode(RunStreamEvent.self) {
            self = .runStreamEvent(value)
        } else if let value = try? container.decode(RunStepStreamEvent.self) {
            self = .runStepStreamEvent(value)
        } else if let value = try? container.decode(MessageStreamEvent.self) {
            self = .messageStreamEvent(value)
        } else if let value = try? container.decode(ErrorEvent.self) {
            self = .errorEvent(value)
        } else if let value = try? container.decode(DoneEvent.self) {
            self = .doneEvent(value)
        } else {
            throw DecodingError.dataCorruptedError(
                in: container,
                debugDescription: "Data could not be decoded as any of the expected types (ThreadStreamEvent, RunStreamEvent, RunStepStreamEvent, MessageStreamEvent, ErrorEvent, DoneEvent)."
            )
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .threadStreamEvent(let value): try container.encode(value)
        case .runStreamEvent(let value): try container.encode(value)
        case .runStepStreamEvent(let value): try container.encode(value)
        case .messageStreamEvent(let value): try container.encode(value)
        case .errorEvent(let value): try container.encode(value)
        case .doneEvent(let value): try container.encode(value)
        }
    }
}
