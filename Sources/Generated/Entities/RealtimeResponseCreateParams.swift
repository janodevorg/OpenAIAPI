// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Create a new Realtime response with these parameters
public struct RealtimeResponseCreateParams: Codable {
    /// The set of modalities the model can respond with. To disable audio,
    /// set this to ["text"].
    public var modalities: [Modality]?
    /// The default system instructions (i.e. system message) prepended to model 
    /// calls. This field allows the client to guide the model on desired 
    /// responses. The model can be instructed on response content and format, 
    /// (e.g. "be extremely succinct", "act friendly", "here are examples of good 
    /// responses") and on audio behavior (e.g. "talk quickly", "inject emotion 
    /// into your voice", "laugh frequently"). The instructions are not guaranteed 
    /// to be followed by the model, but they provide guidance to the model on the 
    /// desired behavior.
    /// 
    /// Note that the server sets default instructions which will be used if this 
    /// field is not set and are visible in the `session.created` event at the 
    /// start of the session.
    public var instructions: String?
    /// The voice the model uses to respond. Voice cannot be changed during the 
    /// session once the model has responded with audio at least once. Current 
    /// voice options are `alloy`, `ash`, `ballad`, `coral`, `echo` `sage`, 
    /// `shimmer` and `verse`.
    public var voice: Voice?
    /// The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.
    public var outputAudioFormat: OutputAudioFormat?
    /// Tools (functions) available to the model.
    public var tools: [Tool]?
    /// How the model chooses tools. Options are `auto`, `none`, `required`, or 
    /// specify a function, like `{"type": "function", "function": {"name": "my_function"}}`.
    public var toolChoice: String?
    /// Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8.
    public var temperature: Double?
    /// Maximum number of output tokens for a single assistant response,
    /// inclusive of tool calls. Provide an integer between 1 and 4096 to
    /// limit output tokens, or `inf` for the maximum available tokens for a
    /// given model. Defaults to `inf`.
    public var maxResponseOutputTokens: MaxResponseOutputTokens?
    /// Controls which conversation the response is added to. Currently supports
    /// `auto` and `none`, with `auto` as the default value. The `auto` value
    /// means that the contents of the response will be added to the default
    /// conversation. Set this to `none` to create an out-of-band response which 
    /// will not add items to default conversation.
    public var conversation: Conversation?
    /// Set of 16 key-value pairs that can be attached to an object. This can be
    /// useful for storing additional information about the object in a structured
    /// format. Keys can be a maximum of 64 characters long and values can be a
    /// maximum of 512 characters long.
    public var metadata: [String: AnyJSON]?
    /// Input items to include in the prompt for the model. Creates a new context
    /// for this response, without including the default conversation. Can include
    /// references to items from the default conversation.
    public var input: [RealtimeConversationItem]?

    public enum Modality: String, Codable, CaseIterable {
        case text
        case audio
    }

    /// The voice the model uses to respond. Voice cannot be changed during the 
    /// session once the model has responded with audio at least once. Current 
    /// voice options are `alloy`, `ash`, `ballad`, `coral`, `echo` `sage`, 
    /// `shimmer` and `verse`.
    public enum Voice: String, Codable, CaseIterable {
        case alloy
        case ash
        case ballad
        case coral
        case echo
        case sage
        case shimmer
        case verse
    }

    /// The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.
    public enum OutputAudioFormat: String, Codable, CaseIterable {
        case pcm16
        case g711Ulaw = "g711_ulaw"
        case g711Alaw = "g711_alaw"
    }

    public struct Tool: Codable {
        /// The type of the tool, i.e. `function`.
        public var type: `Type`?
        /// The name of the function.
        public var name: String?
        /// The description of the function, including guidance on when and how 
        /// to call it, and guidance about what to tell the user when calling 
        /// (if anything).
        public var description: String?
        /// Parameters of the function in JSON Schema.
        public var parameters: [String: AnyJSON]?

        /// The type of the tool, i.e. `function`.
        public enum `Type`: String, Codable, CaseIterable {
            case function
        }

        public init(type: `Type`? = nil, name: String? = nil, description: String? = nil, parameters: [String: AnyJSON]? = nil) {
            self.type = type
            self.name = name
            self.description = description
            self.parameters = parameters
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.type = try values.decodeIfPresent(`Type`.self, forKey: "type")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.description = try values.decodeIfPresent(String.self, forKey: "description")
            self.parameters = try values.decodeIfPresent([String: AnyJSON].self, forKey: "parameters")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(type, forKey: "type")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(description, forKey: "description")
            try values.encodeIfPresent(parameters, forKey: "parameters")
        }
    }

    /// Maximum number of output tokens for a single assistant response,
    /// inclusive of tool calls. Provide an integer between 1 and 4096 to
    /// limit output tokens, or `inf` for the maximum available tokens for a
    /// given model. Defaults to `inf`.
    public enum MaxResponseOutputTokens: Codable {
        case int(Int)
        case object(Object)

        public enum Object: String, Codable, CaseIterable {
            case inf
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(Int.self) {
                self = .int(value)
            } else if let value = try? container.decode(Object.self) {
                self = .object(value)
            } else {
                throw DecodingError.dataCorruptedError(
                    in: container,
                    debugDescription: "Data could not be decoded as any of the expected types (Int, Object)."
                )
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .int(let value): try container.encode(value)
            case .object(let value): try container.encode(value)
            }
        }
    }

    /// Controls which conversation the response is added to. Currently supports
    /// `auto` and `none`, with `auto` as the default value. The `auto` value
    /// means that the contents of the response will be added to the default
    /// conversation. Set this to `none` to create an out-of-band response which 
    /// will not add items to default conversation.
    public enum Conversation: Codable {
        case string(String)
        case object(Object)

        public enum Object: String, Codable, CaseIterable {
            case auto
            case `none`
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(String.self) {
                self = .string(value)
            } else if let value = try? container.decode(Object.self) {
                self = .object(value)
            } else {
                throw DecodingError.dataCorruptedError(
                    in: container,
                    debugDescription: "Data could not be decoded as any of the expected types (String, Object)."
                )
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .string(let value): try container.encode(value)
            case .object(let value): try container.encode(value)
            }
        }
    }

    public init(modalities: [Modality]? = nil, instructions: String? = nil, voice: Voice? = nil, outputAudioFormat: OutputAudioFormat? = nil, tools: [Tool]? = nil, toolChoice: String? = nil, temperature: Double? = nil, maxResponseOutputTokens: MaxResponseOutputTokens? = nil, conversation: Conversation? = nil, metadata: [String: AnyJSON]? = nil, input: [RealtimeConversationItem]? = nil) {
        self.modalities = modalities
        self.instructions = instructions
        self.voice = voice
        self.outputAudioFormat = outputAudioFormat
        self.tools = tools
        self.toolChoice = toolChoice
        self.temperature = temperature
        self.maxResponseOutputTokens = maxResponseOutputTokens
        self.conversation = conversation
        self.metadata = metadata
        self.input = input
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.modalities = try values.decodeIfPresent([Modality].self, forKey: "modalities")
        self.instructions = try values.decodeIfPresent(String.self, forKey: "instructions")
        self.voice = try values.decodeIfPresent(Voice.self, forKey: "voice")
        self.outputAudioFormat = try values.decodeIfPresent(OutputAudioFormat.self, forKey: "output_audio_format")
        self.tools = try values.decodeIfPresent([Tool].self, forKey: "tools")
        self.toolChoice = try values.decodeIfPresent(String.self, forKey: "tool_choice")
        self.temperature = try values.decodeIfPresent(Double.self, forKey: "temperature")
        self.maxResponseOutputTokens = try values.decodeIfPresent(MaxResponseOutputTokens.self, forKey: "max_response_output_tokens")
        self.conversation = try values.decodeIfPresent(Conversation.self, forKey: "conversation")
        self.metadata = try values.decodeIfPresent([String: AnyJSON].self, forKey: "metadata")
        self.input = try values.decodeIfPresent([RealtimeConversationItem].self, forKey: "input")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(modalities, forKey: "modalities")
        try values.encodeIfPresent(instructions, forKey: "instructions")
        try values.encodeIfPresent(voice, forKey: "voice")
        try values.encodeIfPresent(outputAudioFormat, forKey: "output_audio_format")
        try values.encodeIfPresent(tools, forKey: "tools")
        try values.encodeIfPresent(toolChoice, forKey: "tool_choice")
        try values.encodeIfPresent(temperature, forKey: "temperature")
        try values.encodeIfPresent(maxResponseOutputTokens, forKey: "max_response_output_tokens")
        try values.encodeIfPresent(conversation, forKey: "conversation")
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encodeIfPresent(input, forKey: "input")
    }
}
